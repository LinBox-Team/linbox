		lbXrank1 := define_external(rank1,MAPLE,LIB=LinBoxLIBlocation);
		lbXrank2 := define_external(rank2,MAPLE,LIB=LinBoxLIBlocation);
		lbXrank3 := define_external(rank3,MAPLE,LIB=LinBoxLIBlocation);
		lbXmp1 := define_external(minpoly1,MAPLE,LIB=LinBoxLIBlocation);
		lbXmp2 := define_external(minpoly2, MAPLE,LIB=LinBoxLIBlocation);
		lbXmp3 := define_external(minpoly3, MAPLE,LIB=LinBoxLIBlocation);
		lbXdet1 := define_external(det1,MAPLE,LIB=LinBoxLIBlocation);
		lbXdet2 := define_external(det2,MAPLE,LIB=LinBoxLIBlocation);
		lbXdet3 := define_external(det3,MAPLE,LIB=LinBoxLIBlocation);
		lbXapply := define_external(apply,MAPLE,LIB=LinBoxLIBlocation);

		lbXapplyt := define_external(applyt,MAPLE,LIB=LinBoxLIBlocation);

	end proc;

	# Temporary testing line
	create();
	
	LBminpoly := proc(p::posint, M::Matrix(storage=sparse) )
		local L, R, C, D, rows, cols, q, l, i, x;

		if nargs = 3 and type( args[3], name) then
			x := args[3];
		elif nargs = 3 then
			error "Third arguement, if provided, must be name!";
		else 		  # assume there is no symbolic constant
			x := 'x'; # use a default
		fi;

		if op(3,M)[1] = 'datatype = integer[4]' then 
			L := lbXmp1(p,M);
			add(L[i]*x^(i-1),i=1..nops(L));
		elif p < kernelopts(maximmediate) then 
			rows := op(1,M)[1];
			cols := op(1,M)[2];
			q := op(2,M);
			l := nops(q);
			R := Array(1..l, datatype=integer[4]);
			C := Array(1..l, datatype=integer[4]);
			D := Array(1..l, datatype=integer[4]);
			for i from 1 to l do
				R[i] := op(q[i])[1]; C[i] := op(q[i])[2];
				D[i] := op(q[i])[3];
			od;
			L := lbXmp2(p,R,C,D,rows,cols);
			add(L[i]*x^(i-1),i=1..nops(L));;
		else 
			rows := op(1,M)[1];
			cols := op(1,M)[2];
			q := op(2,M);
			l := nops(q);
			R := Array(1..l, datatype=integer[4]);
			C := Array(1..l, datatype=integer[4]);
			D := [seq(MapToEx(op(q[i])[3]),i=1..l)];
			for i from 1 to l do
				R[i] := op(q[i])[1]; C[i] := op(q[i])[2];
			od;
			L := lbXmp3(MapToEx(p),R,C,D,rows,cols);
			add(ExToMap(L[i])*x^(i-1),i=1..nops(L));
		fi;
	end proc;

	LBrank := proc(p::posint, M::Matrix(storage=sparse) )
		local R, C, D, rows, cols, q, i, l;
		if op(3,M)[1] = 'datatype=integer[4]' then 
			lbXrank1(p,M);
		elif p < kernelopts(maximmediate) then
			q := op(2,M);
			l := nops(q);
			R := Array(1..l, datatype=integer[4]);
			C := Array(1..l, datatype=integer[4]);
			D := Array(1..l, datatype=integer[4]);
			for i from 1 to l do
				R[i] := op(q[i])[1];
				C[i] := op(q[i])[2];
				D[i] := op(q[i])[3];
			end do;
			rows := op(1,M)[1];
			cols := op(1,M)[2];
			lbXrank2(p,R,C,D,rows,cols);
		else 
			q := op(2,M);
			l := nops(q);
			R := Array(1..l,datatype=integer[4]);
			C := Array(1..l,datatype=integer[4]);
			D := [seq( MapToEx( op(q[i])[3]),i=1..l)];
			for i from 1 to l do
				R[i] := op(q[i])[1];
				C[i] := op(q[i])[2];
			end do;
			rows := op(1,M)[1];
			cols := op(1,M)[2];
			lbXrank3(MapToEx(p),R,C,D,rows,cols);
		end if;
	end proc;

	LBdet := proc(p::posint, M::Matrix(storage=sparse))
		local R, C, D, rows, cols, q, i, l, A;
		if op(3,M)[1] = 'datatype=integer[4]' then 
			lbXdet1(p,M);
		elif p < kernelopts(maximmediate) then 
			q := op(2,M);
			l := nops(q);
			R := Array(1..l,datatype=integer[4]);
			C := Array(1..l, datatype=integer[4]);
			D := Array(1..l,datatype=integer[4]);
			for i from 1 to l do
				R[i] := op(q[i])[1]; C[i] := op(q[i])[2];
				D[i] := op(q[i])[3];
			od;
			rows := op(1,M)[1]; cols := op(1,M)[2];
			lbXdet2(p,R,C,D,rows,cols);
		else 
			q := op(2,M);
			l := nops(q);
			R := Array(1..l, datatype=integer[4]);
			C := Array(1..l, datatype=integer[4]);
			D := [seq(MapToEx(op(q[i])[3]),i=1..l)];
			for i from 1 to l do
				R[i] := op(q[i])[1]; C[i] := op(q[i])[2];
			od;
			rows := op(1,M)[1]; cols := op(1,M)[2];
			A := detLBI(MapToEx(p),R,C,D,rows,cols);
			ExToMap(A);
		fi;
	end proc;

	MapToEx := proc(num::posint)
		local r, l, i, A;
		if num < kernelopts(maximmediate) then num;
		else
			r := [disassemble](addressof(num));
			l := nops(r) - 1;
			A := Array(1..l, datatype=integer[4]);
			for i from 1 to l do
				A[i] := r[i+1];
			od;
			A;
		fi;
	end proc;

	ExToMap := proc(A::Array(datatype=integer[4]))
		local b0, b, i, s, r;
		b0 := 2^kernelopts(wordsize); b := 1; s = A[1]; r := op(2,A);
		for i from lhs(r) + 1 to rhs(r) do
			b := b0 * b;
			s := s + b * A[i];
		od;
		s;
	end proc;

	LBapply := proc(p::posint, M::Matrix(storage=sparse),x::Vector(datatype=integer[4]) )
		local R, C, D, rows, cols, q, i, l, ind, vdat;

		if p > 2^kernelopts(wordsize) then 
			error "ERROR!  Apply calculation limited to wordsize fields!"; end if;
		q := op(2,M);
		l := nops(q);
		D := Array(1..l, datatype=integer[4]);
		R := Array(1..l, datatype=integer[4]);
		C := Array(1..l, datatype=integer[4]);

		for i from 1 to l do
			D[i] := rhs(q[i]);
			R[i] := lhs(q[i])[1];
			C[i] := lhs(q[i])[2];
		od;

		rows := op(1,M)[1];
		cols := op(1,M)[2];

		q := op(2,x);		
		ind := [seq(lhs(q[i]),i=1..nops(q))];
		vdat := [seq(rhs(q[i]),i=1..nops(q))];
		lbXapply(p, D, R, C, rows, cols, ind, vdat, nops(q));
		
	end proc;

	LBapplyTranspose := proc(p::posint, M::Matrix(storage=sparse),x::Vector(dattype=integer[4]) )
		local R, C, D, rows, cols, q, i, l, ind, vdat;

		if p > 2^kernelopts(wordsize) then 
			error "ERROR!  Apply calculation limited to wordsize fields!"; end if;

		q := nops(q);
		l := nops(q);
		D := Array(1..l, datatype=integer[4]);
		R := Array(1..l, datatype=integer[4]);
		C := Array(1..l, datatype=integer[4]);
		for i from 1 to l do
			D[i] := rhs(q[i]);
			R[i] := lhs(q[i])[1];
			C[i] := lhs(q[i])[2];
		od;

		rows := op(1,M)[1];
		cols := op(1,M)[2];

		q := op(2,x);
		ind := [seq(lhs(q[i]),i=1..nops(q))];
		vdat := [seq(rhs(q[i]),i=1..nops(q))];
		lbXapplyt(p, D, R, C, rows, cols, ind, vdat, nops(q));
	end proc;
end module;

