\section{Containers architecture}\label{sec:container}
%
\linbox is mainly conceived around the RAII (Resource Acquisition Is
Initialisation, see \cite{stroustrup1994design}) concept with re-entrant
function. We also follow the {founding scope allocation} model (or \emph{mother
model}) from \cite{Dumas:2010:lbpar} which ensures that the memory used by
objects is allocated in the constructor and freed only at its destruction. The
gestion of the memory allocated by an object is then exlusively reserved to it.
%
\par
%
\linbox essentially uses matrix and vectors over fields and rings as data objects
(containers).  The fragmentation of the containers into various matrix and
blackbox types needed to be addressed and simplified. The many different matrix and
vector types with different interfaces needed to be reduced into only two
(possibly essentially one in the future) containers: \texttt{Matrix} and
\texttt{Vector}.
%
\subsection{General Interface for %Vectors and
Matrices}
%
First, in order to allow operations on its elements, a container is
parametrized by a field object (\Cref{code:clmat}), not the field's element
type. This is simpler and more general. 
Indeed, the field element type can be infered from a
\texttt{value_type} type definition within the field type.
Then, the storage type is given by a second
template parameter that can use defaults,
\eg dense BLAS matrices (stride
and leading dimension or increment), or some sparse format.
% what else can it be? It can default to other dense formats such as vectors of
% rows or anything.
%
\input{lst_container}
%
In the mother model, we must distinguish containers that own (are responsible
for allocated memory) and containers that share some memory.  The
\texttt{SubMatrix} and \texttt{SubVector} types share the memory while
\texttt{Matrix} and \texttt{Vector} own it.
%
The common interface shared by all container matrices is the \applin  interface
described in the following paragraphs, that accomodates both owner and sharer
container types, and defines the minimal methods required to be a
template \applin type:
% \Cref{code:bb}.
%
% \input{lst_applin}
%
% \begin{description}
%
	% \item[Input/Output.]
\def\monitem#1{\par\textit{#1}\ }
\monitem{Input/Output.}
		Our matrix all read and write from MatrixMarket
		format\footnote{See \url{http://math.nist.gov/MatrixMarket/}.})
		which is well established in the numerical linear algebra
		community.  This allows for easy exchange and
		interoperability, but \linbox containers can also add some
		comments to the file, for instance the field characteristics
		(modulo, irreducible polynomial, {\tt init} function,
		rank,\ldots) We can adapt the header to suit our needs, and
		even create new formats that save space (CSR fashion saving
		roughly a third space over COO), or dedicated to structured
		matrices.
%
	% \item[Accessing Elements.]
		\monitem{Accessing Elements.}
		The function \texttt{setEntry} can be
		used to populate the matrix (from some \texttt{init()} until a
		\texttt{finish()} is emitted).  The function \texttt{setEntry}
		can be (very) costly (for some sparse formats for instance)
		% (\danger Dave, more words on the init/finish?)
% so set entry should always build some COO or CSR and then
% convert to the format.
%
		Other functions such as {\tt refEntry} (that retrieves a
		writable reference to an entry) may be difficult to implement
		or inefficient (compressed fields, sparse matrices);
		\texttt{getEntry} may be specialized, in all cases, there is a
		solution for this operation falling back to the {\tt apply}
		method.
		% The function {\tt clearEntry} may be used to zero an entry and
		% update the storage.
		% (\danger setEntry to zero is sometimes
		% buggy, is this a feature?)
		%
		% \par
		%
		Accessing (read or write) elements, rows or columns through
		iterators, although handy, is not required because it can be
		tricky to implement (compressed fields, hybrid or
		recursive formats). Traits on matrices where efficient iterators
		are available allow for their selections in some algorithms.
		\begin{comment}
		(\danger We cannot have {\tt const} iterators for all formats
		(see hybrid), walking through a matrix in unspecified order can
		be problematic, for instance, in an hom when a zero may
		alter/change the representation. I don't understand hom more
		than I understand init/rebind by the way, and I won't
		understand it until the morphism is given/chooseable/enforced.
		Rebind is really hom, so why is it in the interface anyway?
		This is the same with getEntry. We don't require it because we
		have a solution. Also, if apply is to be implemented via a
		domain or {\tt mul}, we could stress it is in the interface for
		convenience when writing code only. End of \danger)
		\end{comment}
%
	% \item[Apply method.]
		\monitem{Apply method.}
		This is essential in the \applin interface (\Cref{ssec:apply,sec:matmul}).
%
	% \item[Rebind/Conversions.]
		\monitem{Rebind/Conversions.}
		Rebind from one field to the other (if
		possible, using some default homeomorphism).
%
	 Conversion mechanisms between formats are added to the interface when
	 convenient, for instance all sparse matrix formats can convert to/from
	 CSR format.  This `star' mechanism can simplify the code (to the
	 expense of memory usage) and may speed it up when the mother format
	 (CSR for instance) is well tuned for some task. Such tasks could be
	 read/write from a file for instance, or update the matrix.
%
% \end{description}
	 % \paragraph{}
	 \par
%
This is a common minimal interface to all our matrices that can be used by all
of our algorithms. Additional elements to a container can be added, and flagged
with a trait. This model also ensures basic ``linear application'' use of a
matrix (blackbox) which is the least one can request from a matrix.  For
instance, this interface is shared by: Our \emph{dense} containers (BLAS type or
vector of rows); Our  \emph{permutations} containers (compressed \textsc{Lapack} or
cycle representation); Our \emph{sparse} formats (based on common formats such as
COO, CSR,\ldots\ or based on STL containers such as {\tt map}, {\tt deque}, {\tt
pair},\ldots); Our \emph{structured} containers (Diagonal, Hankel, Butterfly,\ldots);
Our \emph{compound} containers (Sum, Compose, Submatrix,\ldots).
%
\subsection{The \texttt{apply} method}\label{ssec:apply}
%
% We will discuss the \texttt{apply} function in \Cref{sec:apply}.
% Both vec/mat
%
\par
%
The \texttt{apply} method (left or right) is arguably the most important
feature in the matrix interface and the \linbox library. It performs what a
linear application is defined for: apply to a vector (and by extension  a block
of vectors, \ie a matrix).
%
\par
%
We propose the new interface (\Cref{code:apply}), where {\tt \_In} and {\tt
\_Out} are vector or matrices, and {\tt Side} is either {\tt Tag::Right} or
{\tt Tag::Left}, whether the operation $y \gets A^{\top} x$ or  $y \gets A x$ is
performed. We also generalize to the operation $y \gets \alpha A x + \beta y$ as
it is often handy and efficient to allow for accumulation.
%
\input{lst_apply}
%
This method is important for two reasons: first it is the building block of the
\applin algorithms (for instance Wiedemann and block-Wiedemann); second the
matrix multiplication is a basic operation in linear algebra that needs to be
extremely efficient (this is the matter of \Cref{sec:matmul}).
%
%
% \par
%
The implementation of the apply method can be left to the {\tt mul} solution
(see \Cref{sec:matmul}), with possibly a helper/method argument if the apply
parameters are specialized enough.
%
% \Cref{code:applymul}.
%
% Usually,  the {\tt apply} method for
% containers is strongly dependant on the representation of the matrix. In
% the case of Hybrid containers, it will simply be calls to the {\tt apply}
% method of the children.
%
