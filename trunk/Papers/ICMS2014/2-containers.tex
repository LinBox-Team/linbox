\section{Containers architecture}\label{sec:container}
%
\linbox is mainly conceived around the RAII concept with re-entrant function
(Resource Acquisition Is Initialisation), introduced by
\cite{stroustrup1994design}. We also follow the {founding scope allocation}
model (or \emph{mother model}) from \cite{Dumas:2010:lbpar} which ensures that
the memory used by objects is allocated in the constructor and freed only at
its destruction. The gestion of the memory allocated by an object is then
exlusively reserved to it.
%
\par
%
\linbox essentially uses matrix and vectors over fields as data objects
(containers).  The fragmentation of the containers into various matrices and
blackboxes needed to be addressed and simplified. The many different matrix and
vector types with different interfaces needed to be reduced into only two
(possibly essentially one in the future) containers: \texttt{Matrix} and
\texttt{Vector}.
%
\subsection{General Interface for %Vectors and
Matrices}
%
Firstly, in order to allow operations on its elements, a container is
parametrized by a field (\cf \Cref{code:clmat}), not the element type; this is
also more general.  The storage type is given by another template parameter
that can default to \eg dense BLAS type matrices (a stride and a leading
dimension or an increment).
%
\input{lst_container}
%
In the mother model, we need types that own or and types that share some
memory.  The \texttt{SubMatrix} and \texttt{SubVector} types share the memory
while \texttt{Matrix} and \texttt{Vector} own it.
%
The common interface shared by all matrices is the \applin  interface described
in the following paragraphs.
% \Cref{code:bb}.
%
% \input{lst_applin}
%
\begin{description}
%
	\item[Input/Output.] Our matrix all read and write from MatrixMarket
		format (ref, link).  Adding extra comments ? (for instance the
		{\tt init} field function in GF(q) needs a polynomial\ldots) We
		can adapt the hearder to suit our needs. In particular write
		matrix in CSR fashion (saving roughly 1/3 space over COO)
%
	\item[Accessing Elements.] The function \texttt{setEntry(...)} can be
		used to populate/grow the matrix (from some \texttt{init()}
		until a \texttt{finish()} is emitted).  The function
		\texttt{setEntry} can be (very) costly (for some sparse formats
		for instance) (Dave ?)
% so set entry should always build some COO or CSR and then
% convert to the format.
%
		\begin{itemize}
			%
			\item \texttt{refEntry} that retrieves a reference to
				an entry may be difficult to implement or
				inefficient (compressed fields, sparse
				matrices)
			%
			\item \texttt{getEntry} may be specialized, in all
				cases, there is a solution for this operation
				(can always be implemented from \texttt{imply},
				\cf{} later.
			%
			\item \texttt{clearEntry} can be used to zero out an
				entry, especially for a sparse matrix, if this
				is allowed (possibly not for structured
				matrices).
			%
			\item iterators may be difficult to implement (but a
				lot of code relies on them\ldots). Do we want
				only {\tt const} iterators ?
%
		\end{itemize}
%
	\item[Apply method.]
		Described later
%
	\item[Rebind] Rebind from one field to the other
%
	\item[Other] Conversion mechanism Added to the interface is a convert
		method to/from CSR (default) for sparse matrix.
%
\end{description}
%
\subsection{The \texttt{apply} method}
%
% We will discuss the \texttt{apply} function in \Cref{sec:apply}.
% Both vec/mat
%
\par
%
The \texttt{apply} method (left or right) is arguably the most important
feature in the matrix interface and the \linbox library. It performs what a
linear application is defined for: apply to a vector (and by extension  a block
of vectors, \ie a matrix).
%
\par
%
We propose the new interface (\Cref{code:apply}), where {\tt \_In} and {\tt
\_Out} are vector or matrices, and {\tt Side} is either {\tt Tag::Right} or
{\tt Tag::Left}, wether the operation $y \gets A^{\top} x$ or  $y \gets A x$ is
performed.
%
\input{lst_apply}
%
This method is important for two reasons: first it is the building block of the
\applin algorithms (for instance Wiedemann and block-Wiedemann); second the
matrix multiplication is a basic operation in linear algebra that needs to be
extremely efficient (this is the matter of \Cref{sec:matmul}).
%
% The apply method should be using a \texttt{mul} solution as in the
% \Cref{code:applymul}.
%
%
\paragraph{Matrix Formats}
%% TRANSITION %%
Dense matrix for instance BLAS, inherits from the iterators of {\tt
std::vector}.
%
All other matrices (including the special case of Permutations) : the same
Structured matrices, add, sub, stacked,\dots
%
Now special case of Sparse Matrix.
%
\subsection{The Sparse Matrix Case}
%
Sparse matrices are usually problematic because the notion of \emph{sparsity}
is too general and the matrices we use are usually very specific: the
algorithms have to adapt to the shape of the sparse matrices.  Getting the best
performance for an sparse matrix as an \applin is not an easy task. In
\cite{Boyer:2010:spmv} we developped some techniques to improve the \spmv
(Sparse Matrix Vector multiplication). There is a huge literature on sparse
matrix formats and \spmv, some of which are becoming standard. Numerical
analysis brings various shapes for sparse matrices and numerous algorithms and
routines.  Just like the \textsc{Blas} numerical routines, we would like to
take advantage of existing high performance libraries. They are however not
very widespread, for instance sparse blas in intel mkl (only). Metis for graph
partitionning.  zero-one matrices are special (no numerical routines)
%
\par
%
Legacy \linbox sparse matrix formats: STL structures (map,\ldots)
%
Helper structure to store a matrix as a sum of structures (HYB), possibly the
transpose. Memory.  Reduce inits on Z/pZ.
%
\par
%
%
\par
%
XXX timing new matrices, example rank.
%
%

