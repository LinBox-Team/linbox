\section{Containers architecture}\label{sec:container}
%
\linbox is mainly conceived around the RAII concept with re-entrant function
(Resource Acquisition Is Initialisation), introduced by
\cite{stroustrup1994design}. We also follow the {founding scope allocation}
model (or \emph{mother model}) from \cite{Dumas:2010:lbpar} which ensures that
the memory used by objects is allocated in the constructor and freed only at
its destruction. The gestion of the memory allocated by an object is then
exlusively reserved to it.
%
\par
%
\linbox essentially uses matrix and vectors over fields and rings as data objects
(containers).  The fragmentation of the containers into various matrix and
blackbox types needed to be addressed and simplified. The many different matrix and
vector types with different interfaces needed to be reduced into only two
(possibly essentially one in the future) containers: \texttt{Matrix} and
\texttt{Vector}.
%
\subsection{General Interface for %Vectors and
Matrices}
%
First, in order to allow operations on its elements, a container is
parametrized by a field object (\cf \Cref{code:clmat}), not the field's element type. This simpler and 
more general.  The storage type is given by a second template parameter
that can default to \eg dense BLAS type matrices (a stride and a leading
dimension or an increment).  % what else can it be?
%
\input{lst_container}
%
In the mother model, we must distinguish containers that own (are responsible for allocated memory) and containers that share some
memory.  The \texttt{SubMatrix} and \texttt{SubVector} types share the memory
while \texttt{Matrix} and \texttt{Vector} own it.
%
The common interface shared by all matrices is the \applin  interface described
in the following paragraphs.
% \Cref{code:bb}.
%
% \input{lst_applin}
%
\begin{description}
%
	\item[Input/Output.] Our matrix all read and write from MatrixMarket
		format (ref, link).  Adding extra comments ? (for instance the
		{\tt init} field function in GF(q) needs a polynomial\ldots) We
		can adapt the hearder to suit our needs. In particular write
		matrix in CSR fashion (saving roughly 1/3 space over COO)
%
	\item[Accessing Elements.] The function \texttt{setEntry(...)} can be
		used to populate/grow the matrix (from some \texttt{init()}
		until a \texttt{finish()} is emitted).  The function
		\texttt{setEntry} can be (very) costly (for some sparse formats
		for instance) (Dave ?)
% so set entry should always build some COO or CSR and then
% convert to the format.
%
		\begin{itemize}
			%
			\item \texttt{refEntry} that retrieves a reference to
				an entry may be difficult to implement or
				inefficient (compressed fields, sparse
				matrices)
			%
			\item \texttt{getEntry} may be specialized, in all
				cases, there is a solution for this operation
				(can always be implemented from \texttt{imply},
				\cf{} later.
			%
			\item \texttt{clearEntry} can be used to zero out an
				entry, especially for a sparse matrix, if this
				is allowed (possibly not for structured
				matrices).
			%
			\item iterators may be difficult to implement (but a
				lot of code relies on them\ldots). Do we want
				only {\tt const} iterators ?
%
		\end{itemize}
%
	\item[Apply method.]
		This is essential in the \applin interface, and we'll described
		it in \Cref{ssec:apply,sec:matmul}.
%
	\item[Rebind] Rebind from one field to the other (if possible, using some default homeomorphism)
%
	\item[Other] Conversion mechanisms are added to the interface when
		convenient, for instance all sparse matrix formats can convert
		to/from CSR format. This `star' mechanism can simplify the code
		(to the expense of memory).
%
\end{description}
%
\subsection{The \texttt{apply} method}\label{ssec:apply}
%
% We will discuss the \texttt{apply} function in \Cref{sec:apply}.
% Both vec/mat
%
\par
%
The \texttt{apply} method (left or right) is arguably the most important
feature in the matrix interface and the \linbox library. It performs what a
linear application is defined for: apply to a vector (and by extension  a block
of vectors, \ie a matrix).
%
\par
%
We propose the new interface (\Cref{code:apply}), where {\tt \_In} and {\tt
\_Out} are vector or matrices, and {\tt Side} is either {\tt Tag::Right} or
{\tt Tag::Left}, wether the operation $y \gets A^{\top} x$ or  $y \gets A x$ is
performed.
%
\input{lst_apply}
%
This method is important for two reasons: first it is the building block of the
\applin algorithms (for instance Wiedemann and block-Wiedemann); second the
matrix multiplication is a basic operation in linear algebra that needs to be
extremely efficient (this is the matter of \Cref{sec:matmul}).
%
% The apply method should be using a \texttt{mul} solution as in the
% \Cref{code:applymul}.
%
%
\subsection{Examples of Containers}
%
First, we have the dense containers that follow some BLAS conventions (row
major ordering, leading dimension or increment,\ldots) and are based on {\tt
std::vector} (inheriting for instance the iterators). In the same fashion, we
have permutations matrices that follow the compressed \textsc{Lapack} format or
more traditional representations.
%
\par
%
We have many kinds of structured or compound matrices (Hankel, stacked, add, sub,\ldots)
All other matrices (including the special case of Permutations) : the same
Structured matrices, add, sub, stacked,\dots
%
\par
%
Finally, the sparse matrices are very important containers and require
particular interest because they are the basis of our \applin algorithms.
%
%
Sparse matrices are usually problematic because the notion of \emph{sparsity}
is too general \emph{vs.} the specificity of real world sparse matrices: the
algorithms have to adapt to the shape of the sparse matrices ---which is not really the case
for the dense case.
%
Getting the best performance for an sparse matrix as an \applin is not a
challenging task. There is a huge literature on \spmv (Sparse Matrix Vector
multiplication) and on sparse matrix formats, some of which are becoming
standard (COO, CSR, BCSR, SKY,\ldots).  In \cite{Boyer:2010:spmv} we developped
some techniques to improve the \spmv operation in \linbox.
Just like the \textsc{Blas} numerical
routines, we would also like to take advantage of existing high performance
numerical libraries (come back to this later).
%
\par
%
The addition of standard matrix format is driven by the availability of
numerical routines and the expectation of better performance in the \spmv
operation. However, legacy \linbox sparse matrix formats (based on STL
structures such as {\tt map}, {\tt deque}, {\tt pair},\ldots) can be more
convenient for elimination techniques.
%
%
\par
%
%XXX timing new matrices, example rank.
%
%
