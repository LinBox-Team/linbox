\section{Containers architecture}\label{sec:container}
%
\linbox is mainly conceived around the RAII concept with re-entrant function
(Resource Acquisition Is Initialisation), introduced by
\cite{stroustrup1994design}. We also follow the {founding scope allocation}
model (or \emph{mother model}) from \cite{Dumas:2010:lbpar} which ensures that
the memory used by objects is allocated in the constructor and freed only at
its destruction. The gestion of the memory allocated by an object is then
exlusively reserved to it.
%
\par
%
\linbox essentially uses matrix and vectors over fields as data objects
(containers).  The fragmentation of the containers into various matrices and
blackboxes needed to be addressed and simplified. The many different matrix and
vector types with different interfaces needed to be reduced into only two
(possibly essentially one in the future) containers: \texttt{Matrix} and
\texttt{Vector}.
%
\subsection{General Vectors and Matrices}
%
Firstly, in order to allow operations on its elements, a container is
parametrized by a field, not the element type; this is also more general.  The
storage type is given by another template parameter that can default to \eg
dense BLAS type matrices, \cf the \Cref{code:clmat}.
%
\input{lst_container}
%
\subsubsection{Interface of the containers.}
%
In the mother model, we need types that own or and types that share some
memory.  The \texttt{SubMatrix} and \texttt{SubVector} types share the memory
while \texttt{Matrix} and \texttt{Vector} own it.
%
The common interface to all matrices is the \applin  interface described in
\Cref{code:bb}.
%
\input{lst_applin}
%
\begin{remark}
%
	Some functions are not part of the default interface :
			%
	\begin{itemize}
			%
		\item \texttt{refEntry} that retrieves a reference to an entry
			may be difficult to implement or inefficient
			(compressed fields, sparse matrices)
			%
		\item \texttt{getEntry} may be specialized, in all cases, there
			is a solution for this operation (can always be
			implemented from \texttt{imply}, \cf{} later.
			%
		\item \texttt{clearEntry} can be used to zero out an entry,
			especially for a sparse matrix, if this is allowed
			(possibly not for structured matrices).
			%
		\item iterators may be difficult to implement (but a lot of
			code relies on them\ldots). Do we want only {\tt const}
			iterators ?
	\end{itemize}
%
The function \texttt{setEntry(...)} can be used to populate/grow the matrix (from some
\texttt{init()} until a \texttt{finish()} is emitted).  The function \texttt{setEntry} can be (very)
costly (for some sparse formats for instance) (Dave ?)
% so set entry should always build some COO or CSR and then
% convert to the format.
%
% \danger needs trait system for algos to adapt. How to check at compile time
% (static\_assert) ?
\end{remark}
%
\subsubsection{Input/Output.}
%
Our matrix all read and write from MatrixMarket format (ref, link).
Adding extra comments ? (for instance the init function in GF(q) needs a polynomial\ldots)
%
\subsection{The \texttt{apply} method}
%
We will discuss the \texttt{apply} function in \cref{sec:apply}.
vec/mat
%
\par
%
The \texttt{apply} method (left or right) is arguably the most important feature in the
matrix interface and the \linbox library. It performs what a linear application is defined for:
apply to a vector (and by extension  a block of vectors, \ie a matrix).
%
\par
%
Proposed interface :
%
{
\begin{lstlisting}
// y = A.x
template< class _In, class _Out  >
_Out& apply(_Out &y, const _In& x, enum Side) ;

// y = alpha y + beta A.x
template< class _In, class _Out  >
_Out& applyAcc(_Out &y, const Element& alpha, const _In& x, const Element& beta, enum Side) ;

\end{lstlisting}
\lstcapt{Proposed apply.\label{code:apply}}
}
%
The apply method should be using a \texttt{mul} solution as in the \Cref{code:applymul}.
{
\begin{lstlisting}
template<class _outVector, class _inVector>
OutVector &apply (_outVector &y, const _inVector &x) const
{
	/* return _MD.vectorMul (y, *this, x); */
	return blas3::mul(y, *this, x); // selects the best mul algorithm
}
\end{lstlisting}
\lstcapt{Implantation d'\texttt{apply} sur un vecteur par solution
\texttt{mul}.\label{code:applymul}}
}
%
\subsection{Sparse Matrix}
%
Sparse matrices are usually problematic because the notion of \emph{sparsity} is too general and the matrices
we use are usually very specific: the algorithms have to adapt to the shape of the sparse matrices.
Getting the best performance for an sparse matrix as an \applin is not an easy task
(\cf \cite{Boyer:2010:spmv}). There is a huge litterature
on sparse matrix formats, some of which are becoming standard. Numerical
analysis brings various shapes for sparse matrices and numerous algorithms and
routines.  Just like the \textsc{Blas} numerical routines, we would like to
take advantage of existing high performance libraries. They are however not very widespread, for instance
sparse blas in intel mkl (only).
%
\par
%
\danger  metis, sparse suite, zero-one matrices
%
\par
%
Matrix market matrices must be supported (we have a convertor in ffspmvgpu, I should commit it)
%
\par
%
SparseMatrix are Matrix with specified storage : COO, CSR, CSC, ELL,
ELL\_R,..., and more to come. (including 0-1 based)
%
\par
%
{
\def\indexTrait{other}
\begin{lstlisting}
namespace matrixStorage {
        struct sparse {} ;
        struct COO : public sparse {} ;
        struct CSR : public sparse {} ;
        struct ELL : public sparse {} ;
        struct ELLR: public sparse {} ;
        struct HYB : public sparse {} ;
        ¬\ldots¬
};

template<class _Field >
class Matrix<_Field, matrixStorage::COO> {
        //specialisation  for COO
};
\end{lstlisting}
\lstcapt{Standard sparse matrix formats.\label{code:sparse:nvl}}
}

%
\par
 HYB format is a specialisation for ELL(\_R)+COO/CSR. no easy setEntry (in the
COO/CSR) part ? a function \texttt{optimize()}. Could use \textsf{Metis} too.
litterature for other HYB.
\par
We use MM reader.
\par
Added to the interface is a convert method to/from CSR (default).
%
\par
%
We can adapt the hearder to suit our needs. In particular write matrix in CSR
fashion (saving roughly 1/3 space over COO)
%
\par
%
XXX timing new matrices, example rank.
%
\subsubsection{Other Matrices.}
%
All other matrices (including the special case of Permutations) : the same
Structured matrices, add, sub, stacked,\dots
%


