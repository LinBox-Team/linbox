\subsection{Rebind of coefficient domains}
\subsubsection{Mapping of data between domains}
\linbox makes use of the concept of rebinds for the mapping of data
structures between different coefficient domains.
For instance, in the context of the Chinese remainder algorithm, rebinds
allow to map a matrix over the integers of type, say,
(\texttt{DenseMatrix<PID\_Integer>}) to a modular matrix of type, say,
\\(\texttt{DenseMatrix<Modular<double> >}).

In \linbox, binder adaptors are enclosed
within many data structures and make use of a generic
converter, named \texttt{Hom} and found in \url{linbox/field/hom.h}.
\texttt{Hom} can generically use the \linbox domain's canonical
conversion methods methods \url{init} and \url{convert} from/to the \linbox
Integer type: \texttt{Domain1} $\rightarrow$ \texttt{Integer}
$\rightarrow$ \texttt{Domain2}. 
Moreover, when natural, efficient conversions exists between domains
(e.g. different representations of the same field or one ring embedded in another), generic \texttt{Hom} can be directly bypassed by a specialization~of~\texttt{Hom}.
%\end{paragraph}


\begin{paragraph}
{\em Rebind of dense matrices.}
We illustrate the founding scope allocation model with the use of rebind
functions adapted from the allocators in the STL, on dense matrices.
\begin{verbatim}
template <class Domain> class DenseMatrix {
  typedef DenseMatrix<Domain> Self_t;
  ... 
  template<class AnyDomain> struct rebind{ 
     typedef DenseMatrix <AnyDomain> other;
     operator ()(other& Ap, const Self_t& A, const AnyDomain& D){
       // Performs the modular conversion of A to Ap over D
       typename Self_t::ConstRawIterator A_iter;
       typename other::RawIterator Ap_iter;
       Hom<Field, _Tp1> hom(A. field(), F);
       for (A_iter = A. rawBegin(), Ap_iter = Ap.rawBegin();
            A_iter != A. rawEnd(); ++ A_iter, ++ Ap_iter)
         hom.image (*Ap_iter, *A_iter);
     } 
  };  
}
\end{verbatim}
According to the founding scope allocation model, the function
\texttt{operator()} in charge of the initialization of the matrix cannot 
allocate any memory. This has to be done at the level where the
rebind is called. This also requires a modification of the rebind
operator interface of the STL: the new object is passed by reference.

\end{paragraph}

\subsubsection{Rebind of handlers in the founding scope allocation model}
In the case of BlackBoxes (functions providing only a matrix-vector
product and not necessarily storing any data) the rebind mechanism
becomes more specific. We detail in this section the solution provided
in blackboxes which only store references to other blackboxes, such as
the \texttt{Compose}, \texttt{Transpose}, \texttt{Submatrix}, etc.

Indeed to rebind a blackbox containing only references one should
allocate a new memory zone and rebind the refered blackbox there.
The problem is that a caller, given a \texttt{BlackBox::rebind<Field2>::other}
type, does not necessarily know how to allocate for this object. 
The STL solution is to embed the allocator in each container. 
In \linbox, we propose another solution: the \texttt{other} not only
has different elements, but also can be of a different type.
For instance, the rebind \texttt{other} type of a blackbox containing
a reference will be the same kind of blackbox, but physically storing
the data (and thus owning it). 

For the different blackboxes defined in \linbox which use references,
we thus define a similar class called e.g. \texttt{TransposeOwner},
\texttt{ComposeOwner}, \texttt{SubmatrixOwner}, etc.
These classes store and own their data. Then it suffices for the
rebind sub-class of their reference equivalents to define its
\texttt{other} type to the associated \verb!*Owner! class. The example
of the \texttt{Compose} is given in figure \ref{fig:composeowner}.
\begin{figure}[htbp]
\begin{verbatim}
template <class _Blackbox1, class _Blackbox2> class Compose {
...
  template<typename _Tp1, typename _Tp2 = _Tp1> struct rebind {
    typedef ComposeOwner<
               typename Blackbox1::template rebind<_Tp1>::other,
               typename Blackbox2::template rebind<_Tp2>::other
    > other;
    ...
  };
  const Blackbox1 * _A_ptr;
  const Blackbox2 * _B_ptr;
  
};

template <class _Blackbox1, class _Blackbox2> class ComposeOwner {
...
  template<typename _Tp1, typename _Tp2 = _Tp1> struct rebind {
    typedef ComposeOwner<
               typename Blackbox1::template rebind<_Tp1>::other,
               typename Blackbox2::template rebind<_Tp2>::other
    > other;
    ...
  };
  template<typename _BBt1, typename _BBt2, typename Field>
  ComposeOwner (const Compose<_BBt1, _BBt2> &M, const Field& F)
    : _A_data(*(M.getLeftPtr()), F), _B_data(*(M.getRightPtr()), F) {
        typename Compose<_BBt1, _BBt2>::template rebind<Field>()(*this,M,F);
  }
  template<typename _BBt1, typename _BBt2, typename Field>
  ComposeOwner (const ComposeOwner<_BBt1, _BBt2> &M, const Field& F)
    : _A_data(M.getLeftData(), F), _B_data(M.getRightData(), F) {
        typename ComposeOwner<_BBt1, _BBt2>::template rebind<Field>()(*this,M,F);
  }

  Blackbox1 _A_data;
  Blackbox2 _B_data;
};
\end{verbatim}
\caption{Owner mechanism for the composed blackboxes}
\end{figure}

Not this also fits well in the \linbox
founding scope allocation, since the \verb!*Owner! class will be
declared (and thus allocated) by the caller of the rebind in codes
similar to the following:
\begin{verbatim}
template<class BlackBox> void f(const BlackBox& A) {
...
typedef typename Blackbox::template rebind<Field2>::other FBlackbox;
// rebinds generically the BlackBox A to a BlackBox Ap 
// with a new Domain F2
// The container type of Ap might be different from the one of A
// this decision is made in the rebind type of A, 
// via the 'other' typedef
FBlackbox Ap(A, F2);
...
}
\end{verbatim}

Remark that for a submatrix of a class storing its elements (contrary
to a submatrix of a blackbox containing e.g. only references), a more
efficient rebind would only rebind the elements within the boundaries
of the submatrix. There we use a trait to decide wether the refered
blackbox is a storing component and in the latter case specialize
e.g. \texttt{Submatrix<DenseMatrix<Field1> >::rebind<Field2>::other}
to a simpler \texttt{DenseMatrix<Field2>} instead of using the
\verb!*Owner! mechanism.