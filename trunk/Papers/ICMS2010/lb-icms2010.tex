\documentclass[runningheads,a4paper]{llncs}

\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{calc,listings,color}

\usepackage{url,xspace}

\newcommand{\linboxsp}{{\sc LinBox}\xspace}
\newcommand{\linbox}{{\sc LinBox}}

\begin{document}

\mainmatter  
\title{\linboxsp memory management and parallel model}
%\titlerunning{}
\author{The \linboxsp group}
\maketitle

\section{Introduction}


\section{A lightweight memory management}

\subsection{Call-by-reference}

Only references as argument (no value returned), first args as return
values.

\verb! Matrix & Function( Matrix & result, const XXX& args); !

example of fields \cite[\S 2.1]{jgd:2002:icms} ?

\subsection{The mother model}


The mother model: functions should not allocate their return values

\begin{itemize}
\item more efficient: allocations are limited

\item requires more involvment by the programmer: control of the allocation

\item garbage collection is simplified: reference counting with a single
boolean, or even better (sic) by two different classes.
Especially for thread-safety.
\end{itemize}


\subsection{Rebind of matrices}

mecanism of the rebind for fields adapted from STL rebind of
allocators.

Since rebind must not allocate, only references are given (re)
allocation is done by the caller (and not rebind), rebind only maps
values from one field to another.

\begin{itemize}
\item generic homomorphism 
\verb!e.init( newelt, e.convert( Integer, oldelt) )!
can be specialized.
\end{itemize}

\section{Abstraction of a level for parallelism}
\subsection{Parallel building blocks}

namespace selection of algorithms like \verb!for_each!,
\verb!transform!, etc. 

\begin{itemize}
\item Transparent parallelism
\item Abstraction of parallelism
\item Parallelism really as a plug-in
\end{itemize}

\subsection{Accumulate-while and early termination}
Proposition of a new algorithm:
\verb!Accumulate-while!, generalization of \cite{jgd:2010:crt},
specially adapted to early termination in mathematical softwares.

Other applications (e.g. from \cite{Beaumont:2004:PMAA}) ??


\subsection{Memory contention}
solved (?) with multi-threaded memory allocators ...

\section{Separate compilation}
One solution for management of code bloat was given via
\verb!Archetypes! in \cite[\S 2.1]{jgd:2002:icms}

Here we propose to automatize \cite{Erlingsson:1996:issac} technique:

\begin{itemize}
\item For a given generic algorithm, e.g. \verb!rank!, we define the
  generic algorithm, and its specializations, to be a generic function
  prefixed with \verb!generic!, not supposed to be directly called. See e.g. 
\verb!template<class Matrix> size_t& generic_rank(size_t& rank, const Matrix& A);!
\item Next we automatically define the user interface in a caller that
  high level users should use:
\begin{verbatim}
template<class Matrix> size_t& rank(size_t& rank, const Matrix& A) {
   return generic_rank(r, A);
}
\end{verbatim}
\item Then the separate compilation specialization can be defined,
  according to a compile time decision, i.e. a macro 
\verb!#define __LINBOX_SEPARATE_COMPILATION!
\begin{itemize}
\item If this macro is not set, leave as it is, it works.
\item Otherwise, define in the library, \verb!liblinbox.a!, 
a specific caller, which will instantiate the generic caller e.g,
\begin{verbatim}
size_t& rankOfDenseMatrixOverGF2(size_t& rank, const DenseMatrix<GF2>& A) {
   return rank_implementation(r, A);
}
\end{verbatim}
and then define a specialization of the user level call:
\begin{verbatim}
template<> size_t& rank(size_t& rank, const DenseMatrix<GF2>& A) {
   return rankOfDenseMatrixOverGF2(r, A);
}
\end{verbatim}
\end{itemize}
\end{itemize}

\begin{itemize}
\item thanks to inlining by compiler, the cost is a single extra
  function call (to the pre-compiled code) and not two.
\item speeds-up external usage such as Maple, Sage interfaces:
  compilation timings ?
\end{itemize}

\begin{figure}[ht]
\includegraphics[width=\textwidth]{separate}
\caption{Separate compilation of a rank specialization}\label{fig:sep}
\end{figure}


\begin{table}[ht]
\begin{tabular}{|l||r|r|r|}
\hline
file			& real time & user time & sys time\\
\hline
\hline
rankinstantiate.o 	& 59.00s & 58.13s & 0.86s\\
rankseparate.o 		&  8.87s &  8.53s & 0.33s\\
rankseparate 		&  0.52s &  0.44s & 0.09s\\
\hline
Sep. comp.		& 68.39s & 67.10s & 1.28s\\
\hline
rank 			& 66.91s & 65.92s & 0.89s\\
\hline
speed-up		& 7.1 & 7.3 & 2.1 \\
\hline
\end{tabular} 
\caption{linbox/examples/rank.C compilation time on an AMD Athlon
  3600+, 1.9GHz}\label{tab:compsolve}
\end{table}

\begin{table}[ht]
\begin{tabular}{|l||r|r|r|}
\hline
file			& real time & user time & sys time\\
\hline
\hline
solveinstantiate.o 	& 65.38s & 64.48s & 0.88s\\
solveseparate.o 	& 10.17s &  9.81s & 0.35s\\
solveseparate 		&  0.54s &  0.42s & 0.11s\\
\hline
Sep. comp.		& 76.09s & 74.71s & 1.34s\\
\hline
solve 			& 72.62s & 71.35s & 1.03s\\
\hline
speed-up		& 6.8 & 7.0 & 2.2 \\
\hline
\end{tabular} 
\caption{linbox/examples/solve.C compilation time on an AMD Athlon
  3600+, 1.9GHz}\label{tab:compsolve}
\end{table}


\bibliographystyle{plain}
\bibliography{jgdbibl} 

\end{document}