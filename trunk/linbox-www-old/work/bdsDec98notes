A design proposal:

Have a class template<class EntryRing> class Matrix.
in which the matrices have infinitely many rows and columns (but finitely
many non-zero ones).
This is in analogy with the way we usually handle polynomials.

Over a given field there is one matrix class,   
Each matrix has finite support in index space = PxP, where P={1,2,...}.
However, it may be sensible to include the infinite identity matrix.

This class of matrices forms a ring.  It can be used as an entry domain,
including recursively.  It can also be extended to matrix classes
which store row and col numbers if wished.

Similarly all vectors are infinite with finite support in index space P.

Many concepts then require a size parameter, 
but rank doesn't.
minpoly almost doesn't.
invariant factors almost doesn't
char poly almost doesn't
det almost doesn't.
"non-singular" becomes "unique solution of support in [1..n]".
...

Fundamental theorem of minpolys:  let A be an n by n matrix, and 
let B be the corresponding infinite matrix.
Let f be minpoly(A) = minpoly_n(B) and g be minpoly_inf(B).
(in this notation minpoly_n has zero-th term c*I_n, whereas minpoly_inf
  has zero-th term c*I_inf.)
1. g = { f, if x | f, // 
	 xf, otherwise.
2. f = { g, if x^2 | g, 
	 g/x, if deg(g) = n+1.
	 g/x, if rank(B) = n.
	 g, otherwise.

-------------------------------------------
Language issues.

Write in C++ or Java, but use a system of conventions to minimize the 
differences between C++ and Java code.

For example:

In C++ use single inheritance.

In C++ use template class parameters in a way consistent with Java interfaces.

Use the same type and function naming conventions.
  In particular this means no operator overloading!  
  ... or at least, in C++, provision of a conventionally named member 
  function equivalent to the operator.
  Thus A.operator()(args) [usage A(args)] may be called A.apply(args).

Memory management.
Make extensive use of procedures which provide the memory for the output,
to minimize the dependence on destructors and/or GC.

Thus add(R& c ,R a, R b) rather than R c <- prod(R a, R b)




A personal preference(bds):

Use noun expressions to name functions that return a value.
Use verb expressions to name void functions.

Thus c = product(a,b), but add(&c,a,b)
Thus b = inverse(a,b), but invert(&b,a)
Use special flag in function name when the output parameter canNOT be 
the same as a input parameter. Eg. maybe if name is invertFrom then 
it is likely that the call invertFrom(a,a) will break, whereas the call 
invert(a,a) is guaranteed not o break.

Also 
A.setMember(x) goes with either
A.getMember(&x) or
x <- A.member() [has naming problem]
rather than
x <- A.getMember().
