I have yet to see the "factor of 25" problem with my own eyes.  This
issue haunts me because I want to know the cost of various design 
decisions, especially whether a certain language choice would PREVENT
ELIMINATION of such a factor.  This matter may also affect the suitability
of implementing matrix-vector product using an iterator which traverses
the non-zeroes in the matrix in arbitrary order.

Mark has sent me code showing a FACTOR OF 2 or so for 
vector of int versus vector of pointer-to-int.  
This is for int arithmetic in the innerproduct.

Subsequently he gets a FACTOR OF 2.5 or so for 
vector of int versus vector of pointer-to-seriously-spread-out-ints.  
This is for int arithmetic in the innerproduct. 
(see marktest2.cc in the same dir as the code below)

Yesterday, I reported a FACTOR OF 1 for a direct- versus reference-to-
situation.  However, there is no conflict between this and Mark's observation.
Yesterday's experiment was for innerproduct of int vectors where the difference
was in whether the arithmetic mod p was direct or was accessed thru a pointer
to a (single) field object.

Today I have a FACTOR OF 1.2 or so for 
vector of int versus vector of pointer-to-int. 
This is for int mod p arithmetic in the innerproduct.

In view of Mark's times, my generalization yesterday was too strong.
Now I say:
Generalization 1: Pointer dereferencing is NOT a cost if a sequence of 
references are to the SAME object (eg. the Field object).
Generalization 2: Pointer dereferencing is a MODEST cost, period.

Generalization 2 is weaker because it admits a cost, but stronger because
it makes no reference to locality.  Thus I challenge you to show me 
that locality matters.  Below are my experiments (variant of Mark's code)
aimed at trying to cause cache misses (or whatever) to cause anything 
remotely like the "factor of 25".  I failed to see anything worse than 
a FACTOR OF 3.  (I guess another way you can get me to the factor of 25,
is to show me modest factors like 2 or 3 end up compounded 3 times or so 
in some "natural" code.)  (To say it another way:  Please show me a REALLY
painful cache miss, or dereference, or whatever.)


Conclusions from the following times:

1. int mult costs 3-5 times as much as int add.
2. The cost of int mult is slightly size dependent.
3. There is a factor of 4 to 5 for int mod p arithmetic over int arithmetic 
on innerprod.

The following are for INT MOD P ARITHMETIC on the innerproduct computation.
3. Factor of 1.2 or so for 
vector of int versus vector of pointer-to-int. 
3. Factor of 1.25 or so for 
vector of pointer-to-presumably-localized-int versus 
vector of pointer-to-widely-but-regularly-spaced-int. 
4. Factor of 1.7 or so for 
vector of pointer-to-presumably-localized-int versus 
vector of pointer-to-widely-and-irregularly-spaced-int. 
5. Factor of 3 or so (square of 1.7) for 
vector of pointer-to-presumably-localized-int versus 
vector of pointer-to-widely-and-irregularly-spaced-int when the pointers
themselves are widely and irregularly accessed. (effect we might get when using
an arbitrary traversal of a matrix' non-zero elements?).

----- a test run ------------
g++ -O5 marktest.cc
taygeta.cis.udel.edu: a.out
Vector size, iterations, prime, stride: 1000001 10 101 10000
1000001
 Array of 1000001 int 1's: Time = 1420
100996097
 Array of 1000001 ints with add not mul: Time = 600
-511165568
 Array of 1000001 ints: Time = 1500
45
 Array of 1000001 ints mod 101: Time = 6600
-511165568
 Array of 1000001 refs to ints: Time = 2820
45
 Array of 1000001 refs to ints mod 101: Time = 7890
-511165568
 Array of 1000001 refs to spaced ints: Time = 5840
45
 Array of 1000001 refs to spaced ints mod 101: Time = 10820
45
 Array of 1000001 spaced refs to spaced ints mod 101: Time = 16530
-508854616
 Array of 1000001 refs to variably spaced ints: Time = 8340
16
 Array of 1000001 refs to variably spaced ints mod 101: Time = 13610
56
 Array of 1000001 variably spaced refs to variably spaced ints mod 101: Time = 25730

----- the code -----------
//eecis.udel.edu:/usr/local/algebra/linbox/Matrix/Fieldtmp/marktest.cc 
#include <iostream>
#include <vector>
#include <time.h>

int main() {

   long starttime;   
   int size, iters;
   int q = 65521;
   int stride;
   cout << "Vector size, iterations, prime, stride: ";
   cin >> size >> iters >> q >> stride;

   vector<int> x((size_t)size,1), y((size_t)size,1);
   int z;

   starttime=clock();
   for (int j=0; j<iters; j++) {
     z=0;
     for (int i=0; i<size; i++)
       z+= x[i]*y[i];
   }

   cout << z << endl;
   cout << " Array of " << size << " int 1's: Time = " << (clock() -starttime)/1000 << endl;

   for (int i=0; i<size; i++) {
     x[i]=i&q;
     y[i]=(i+1)&q;
   }

   starttime=clock();
   for (int j=0; j<iters; j++) {
     z=0;
     for (int i=0; i<size; i++)
       z+= x[i]+y[i];
   }

   cout << z << endl;
   cout << " Array of " << size << " ints with add not mul: Time = " << (clock() -starttime)/1000 << endl;

   
   starttime=clock();
   for (int j=0; j<iters; j++) {
     z=0;
     for (int i=0; i<size; i++)
       z+= x[i]*y[i];
   }

   cout << z << endl;
   cout << " Array of " << size << " ints: Time = " << (clock() -starttime)/1000 << endl;

   starttime=clock();
   for (int j=0; j<iters; j++) {
     z=0;
     for (int i=0; i<size; i++)
       z = (z + (x[i]*y[i])%q)%q;
   }

   cout << z << endl;
   cout << " Array of " << size << " ints mod "<<q<<": Time = " << (clock() -starttime)/1000 << endl;

// references to (presumably) adjacent values (adjacent in malloc time at least)
   vector<int*> xx(size), yy(size);
   for (int i=0; i<size; i++) {
     xx[i]=new int; *(xx[i])=i&q;
     yy[i]=new int; *(yy[i])=(i+1)&q;
   }

   starttime=clock();
   for (int j=0; j<iters; j++) {
      z=0;
      for (int i=0; i<size; i++)
        z+=  *(xx[i]) * *(yy[i]);
   }

   cout << z << endl;
   cout << " Array of " << size << " refs to ints: Time = " << (clock() -starttime)/1000 << endl;
   
   starttime=clock();
   for (int j=0; j<iters; j++) {
      z=0;
      for (int i=0; i<size; i++)
       z = (z + (*(xx[i])* *(yy[i]))%q)%q;
   }

   cout << z << endl;
   cout << " Array of " << size << " refs to ints mod "<<q<<": Time = " << (clock() -starttime)/1000 << endl;
   
// references to strided locations
   int ii = 0;
   for (int i=0; i<size; i++) {
     xx[i]=&x[ii];
     yy[i]=&y[ii];
     ii = (ii+stride)%size;
   }

   starttime=clock();
   for (int j=0; j<iters; j++) {
      z=0;
      for (int i=0; i<size; i++)
        z+=  *(xx[i]) * *(yy[i]);
   }

   cout << z << endl;
   cout << " Array of " << size << " refs to spaced ints: Time = " << (clock() -starttime)/1000 << endl;
   
   starttime=clock();
   for (int j=0; j<iters; j++) {
      z=0;
      for (int i=0; i<size; i++)
       z = (z + (*(xx[i])* *(yy[i]))%q)%q;
   }

   cout << z << endl;
   cout << " Array of " << size << " refs to spaced ints mod "<<q<<": Time = " << (clock() -starttime)/1000 << endl;
   
   starttime=clock();
   for (int j=0; j<iters; j++) {
      z=0;
      ii = 0;
      for (int i=0; i<size; i++){
       z = (z + (*(xx[ii])* *(yy[ii]))%q)%q;
	ii = (ii+stride)%size;
      }
   }

   cout << z << endl;
   cout << " Array of " << size << " spaced refs to spaced ints mod "<<q<<": Time = " << (clock() -starttime)/1000 << endl;

// references to spread locations, broken stride   
   int st = stride;
   ii = 0;
   for (int i=0; i<size; i++) {
     xx[i]=&x[ii];
     yy[i]=&y[ii];
     ii = (ii+st)%size;
     st = (st+1)%size;
   }

   starttime=clock();
   for (int j=0; j<iters; j++) {
      z=0;
      for (int i=0; i<size; i++)
        z+=  *(xx[i]) * *(yy[i]);
   }

   cout << z << endl;
   cout << " Array of " << size << " refs to variably spaced ints: Time = " << (clock() -starttime)/1000 << endl;
   
   starttime=clock();
   for (int j=0; j<iters; j++) {
      z=0;
      for (int i=0; i<size; i++)
       z = (z + (*(xx[i])* *(yy[i]))%q)%q;
   }

   cout << z << endl;
   cout << " Array of " << size << " refs to variably spaced ints mod "<<q<<": Time = " << (clock() -starttime)/1000 << endl;
   
     
   st = stride;
   starttime=clock();
   for (int j=0; j<iters; j++) {
      z=0;
      ii = 0;
      for (int i=0; i<size; i++){
       z = (z + (*(xx[ii])* *(yy[ii]))%q)%q;
	ii = (ii+st)%size;
	st = (1+st)%size;
      }
   }

   cout << z << endl;
   cout << " Array of " << size << " variably spaced refs to variably spaced ints mod "<<q<<": Time = " << (clock() -starttime)/1000 << endl;
   
     
   
   
} 

