    |\^/|     Maple 9.5 (IBM INTEL LINUX)
._|\|   |/|_. Copyright (c) Maplesoft, a division of Waterloo Maple Inc. 2004
 \  MAPLE  /  All rights reserved. Maple is a trademark of
 <____ ____>  Waterloo Maple Inc.
      |       Type ? for help.
# full times up to Q52 of dim 1008 (after to cra improvement).
# times of weekend 2005jan14.
> 
# make list of i-th elements of lists L in list of lists LL (only when s <= L[1] <= e).
> extract := proc(LL, i, s, e) local A, L; A := [];
>   for L in LL do if L[1] >= s and L[1] <= e then A := [op(A), L[i]] fi od; A end;
extract := proc(LL, i, s, e)
local A, L;
    A := [];
    for L in LL do
        if s <= L[1] and L[1] <= e then A := [op(A), L[i]] end if
    end do;
    A
end proc

> 
> blb := 23; #bits per prime used in blas, lu. down to 20 at 1008
                                   blb := 23

> bbb := 30; #bits per prime used in bb.
                                   bbb := 30

> Q := [
#Q*Cpt 	#dim	#nnz   #t_bb	#prime	#t_blas	#prime	#t_lu	#prime
> [2,	1.0,	1,	0.0,	2,	0.0,	2,	0.0,	2],
> [3,	8.0,	1046,	0.05,	15,	0.01,	18,	0.0,	18],
> [4,	8.0,	1046,	0.05,	19,	0.0,	22,	0.0,	22],
> [5,	28.0,	4396,	1.08,	98,	0.1,	124,	0.1,	124],
> [6,	28.0,	4396,	0.92,	81,	0.1,	102,	0.06,	102],
> [7,	35.0,	5608,	2.26,	147,	0.23,	186,	0.18,	186],
> [8,	35.0,	5608,	2.5,	164,	0.29,	207,	0.17,	207],
> [9,	50.0,	8800,	9.51,	347,	1.25,	439,	0.88,	439],
> [10,	50.0,	8800,	10.96,	405,	1.53,	514,	1.11,	514],
> [11,	56.0,	9674,	6.41,	198,	0.77,	251,	0.53,	251],
> [12,	56.0,	9674,	7.33,	229,	0.89,	289,	0.60,	289],
> [22,	175.0,	36262,	445.3,	1689,  80.62,	2237,  52.84,	2237],
> [24,	210.0,	41550,	635.57,	1733, 120.7,	2296,  71.84,	2296],
> [32,	448.0,	97960,	5601.23, 3514, 1852.78,	4880, 703.75,	4880],
> [42,	700.0,	150470,	24650,	6421, 11564.2,	8918, 3444.94,	8918],
> [52,	1008.0,	225842, 70517.1, 8973, 42921.8,	12465, 10094.8,	12465] ]:
#Q := [
##"[model dim    bbt    bbp   mt        bt       lt   blp]";
#[2,   	1.0,	0,   	6.0*bbb,     0,		0,	 	0,	7],
#[3,  	8.0,	0.07,	42.0*bbb,    0.07,	0.01,		0.01,	53],
#[4,  	8.0,	0.04,	18.0*bbb,    0.04,	0.01,		0,	22],
#[5,   	28.0,	1.25,	102.0*bbb,   0.67,	0.13,		0.09,	134],
#[6,  	28.0,	3.16,	144.0*bbb,   0.89,	0.21,		0.15,	190],
#[7,  	35.0,	4.21,	216.0*bbb,   1.53,	0.53,		0.41,	287],
#[8,  	35.0,	5.24,	156.0*bbb,   1.75,	0.47,		0.37,	207],
#[9,  	50.0,	15.91,	378.0*bbb,   3.76,	2.32,		1.87,	508],
#[10,  	50.0,	18.59,	387.0*bbb,   3.28,	2.4,		1.87,	521],
#[11,  	56.0,	13.16,	281.0*bbb,   3.62,	1.75,		1.26,	380],
#[12,  	56.0,	11.71,	251.0*bbb,   5.02,	2.02,		1.59,	339],
#[22,  	175.0,	940.61,	1613.0*bbb,  52.84,	266.24,		298.7,	2265],
#[24,  	210.0,	1290.0,	1655.0*bbb,  59.7,	309.47,		353.27,	2339],
#[32,  	448.0,	12885.9, 3567.0*bbb, 330.87, 4885.91,	5292.68, 5169],
#[42,  	700.0,  54483.7, 6132.0*bbb, 745.9,	30076.00,	20788.3, 9011],
#[52,  1008.0,  174879.0, 8746.0*bbb, 1599.1, 109735.0, 	(1622.0*60*12990/9795), 12990] ]; # bogus tl 
> im := 1; idim := 2; innz := 3; ibbt := 4; ibbp := 5; ibt := 6; iblp := 7; ilt := 8; iblp2 := 9; 
                                    im := 1

                                   idim := 2

                                   innz := 3

                                   ibbt := 4

                                   ibbp := 5

                                    ibt := 6

                                   iblp := 7

                                    ilt := 8

                                   iblp2 := 9

> 
> firstmodel := 9; #used in foo
                                firstmodel := 9

> lastmodel := 52; #used in foo
                                lastmodel := 52

> nl := extract(Q, idim, firstmodel, lastmodel); # used in foo
       nl := [50.0, 50.0, 56.0, 56.0, 175.0, 210.0, 448.0, 700.0, 1008.0]

> 
> pbb := extract(Q, ibbp, firstmodel, lastmodel);
           pbb := [347, 405, 198, 229, 1689, 1733, 3514, 6421, 8973]

> 
# bits per prime formula for iblp
> bitsiblp
> := proc(p, n) evalf(p*floor(log[2](sqrt(2^52/n)))) end;
bitsiblp :=

    proc(p, n) evalf(p*floor(log[2](sqrt(4503599627370496/n)))) end proc

> 
# bits pre prime formula for ibbt
> bitsibbp
> := proc(p) evalf(p*30) end;
                    bitsibbp := proc(p) evalf(30*p) end proc

> 
> pb := zip(fo, extract(Q, iblp, firstmodel, lastmodel),
>                  extract(Q, idim, firstmodel, lastmodel)); 
pb := [fo(439, 50.0), fo(514, 50.0), fo(251, 56.0), fo(289, 56.0),

    fo(2237, 175.0), fo(2296, 210.0), fo(4880, 448.0), fo(8918, 700.0),

    fo(12465, 1008.0)]

> 
> with(stats);
  [anova, describe, fit, importdata, random, statevalf, statplots, transform]

> 
# relative error function
> fg := proc(nn, p) evalf(subs(n = nn, op(2, formula1))/p - 1) end;
     fg := proc(nn, p) evalf(subs(n = nn, op(2, formula1))/p - 1) end proc

> 
> bar := proc(lsqarg, pl) global formula1;
> 
>   formula1 := fit[leastsquare[op(lsqarg)]]([pl, nl]);
#  print(formula1);
>   print(evalf(formula1));
> 
>   
> 
>   errg := zip(fg, nl, pl);
>   print("rel errs", errg);
> 
>   [describe[mean](errg),describe[standarddeviation](errg)];
> end;
Warning, `errg` is implicitly declared local to procedure `bar`
bar := proc(lsqarg, pl)
local errg;
global formula1;
    formula1 := fit[leastsquare[op(lsqarg)]]([pl, nl]);
    print(evalf(formula1));
    errg := zip(fg, nl, pl);
    print("rel errs", errg);
    [describe[mean](errg), describe[standarddeviation](errg)]
end proc

> 
> foobar := proc(lsqarg, loc) bar(lsqarg, extract(Q, loc, firstmodel, lastmodel)) end;
foobar := proc(lsqarg, loc)
    bar(lsqarg, extract(Q, loc, firstmodel, lastmodel))
end proc

> 
> foo := proc(lsqarg, loc)
>   if loc = iblp  then
>     pl := zip(bitsiblp, extract(Q, loc, firstmodel, lastmodel), nl);
>   else 
>     pl := map(bitsibbp, extract(Q, loc, firstmodel, lastmodel));
>   fi;
>   #nl := extract(Q, idim, firstmodel, lastmodel);
>   bar(lsqarg, pl)
> end;
Warning, `pl` is implicitly declared local to procedure `foo`
foo := proc(lsqarg, loc)
local pl;
    if loc = iblp then
        pl := zip(bitsiblp, extract(Q, loc, firstmodel, lastmodel), nl)
    else pl := map(bitsibbp, extract(Q, loc, firstmodel, lastmodel))
    end if;
    bar(lsqarg, pl)
end proc

> 
> "blackbox nnz";
                                 "blackbox nnz"

> foobar([[nnz, n],nnz = a*n + b*n*log[2](n), {a,b}], innz);
                   nnz = 132.5900614 n + 13.12471912 n ln(n)

"rel errs", [0.0450810484, 0.0450810484, 0.0733526581, 0.0733526581,

    -0.0329856420, 0.0248270186, -0.0271971875, 0.0168126902, -0.0030913423]

                         [0.02391477222, 0.03714075803]

#foo([[bits, n],bits = a*n, {a}], ibbp);
#foo([[bits, n],bits = a*n*log[2](n), {a}], ibbp);
> "blackbox primes";
                               "blackbox primes"

> foo([[bits, n],bits = a*n + b*n*log[2](n), {a,b}], ibbp);
                   bits = 150.1135835 n + 17.30331255 n ln(n)

"rel errs", [0.0461313174, -0.1036850195, 1.071863318, 0.7913927378,

    -0.1728979544, -0.0199343364, 0.0868386884, -0.0425775746, 0.0102037071]

                          [0.1852594316, 0.4108164784]

#foo([[bits, n],bits = a + b*n + c*n*log[2](n), {a,b,c}], ibbp);
> 
#foo([[bits, n],bits = a*n, {a}], iblp);
#foo([[bits, n],bits = a*n*log[2](n), {a}], iblp);
> "blas, lu primes";
                               "blas, lu primes"

> foo([[bits, n],bits = a*n + b*n*log[2](n), {a,b}], iblp);
                   bits = 145.1060465 n + 16.95126719 n ln(n)

"rel errs", [0.0469436155, -0.1058205307, 1.069476542, 0.7973654395,

    -0.1726998441, -0.0199017674, 0.0867323615, -0.0425537876, 0.0102000384]

                          [0.1855268962, 0.4113460327]

#foo([[bits, n],bits = a + b*n + c*n*log[2](n), {a,b,c}], iblp);
> 
> "blackbox time, one log";
                            "blackbox time, one log"

> foobar([[t, n], t = b*n^3*log(n), {b}], ibbt);
                                               3
                         t = 0.00001004957636 n  ln(n)

"rel errs", [-0.4832521833, -0.5516175421, 0.108300773, -0.0308038258,

    -0.3753143430, -0.2170010730, -0.0151516779, -0.0839105620, 0.009421441]

                         [-0.1821476659, 0.2229105974]

> "blackbox time, two log ";
                           "blackbox time, two log "

> foobar([[t, n], t = b*n^3*log(n)^2, { b}], ibbt);
                                           -5  3      2
                        t = 0.1459993222 10   n  ln(n)

"rel errs", [-0.7063140733, -0.7451685071, -0.3518663771, -0.4332146627,

    -0.5312762611, -0.3917485258, -0.1265392512, -0.1281256800, 0.014175765]

                         [-0.3777863970, 0.2470915725]

> "blackbox time, two log two term";
                       "blackbox time, two log two term"

> foobar([[t, n], t = a*n^3*log(n) + b*n^3*log(n)^2, {a, b}], ibbt);
                                3                        -5  3      2
          t = 0.00002512281656 n  ln(n) - 0.2191492817 10   n  ln(n)

"rel errs", [-0.1490194948, -0.2616035945, 0.797760283, 0.572120521,

    -0.1419238803, 0.044406345, 0.150920317, -0.018587924, 0.001132982]

                          [0.1105783949, 0.3315915199]

> 
> "blas time, one log";
                              "blas time, one log"

> foobar([[t, n], t = b*n^4*log(n), {b}], ibt);
                                            -8  4
                         t = 0.6075421680 10   n  ln(n)

"rel errs", [-0.8811640531, -0.9029118081, -0.6876499069, -0.7297645262,

    -0.6349619323, -0.4765619933, -0.1936277243, -0.1736464108, 0.010597563]

                         [-0.5188545323, 0.3113185786]

> "blas time, two log";
                              "blas time, two log"

> foobar([[t, n], t = b*n^4*log(n)^2, {b}], ibt);
                                           -9  4      2
                        t = 0.8801556602 10   n  ln(n)

"rel errs", [-0.9326508234, -0.9449761629, -0.8178502710, -0.8424097849,

    -0.7268673958, -0.5945220603, -0.2868356812, -0.2157366816, 0.012509074]

                         [-0.5943710874, 0.3287390225]

> "blas time, two log, two term";
                         "blas time, two log, two term"

> foobar([[t, n], t = a*n^4*log(n) + b*n^4*log(n)^2, {a, b}], ibt);
                             -7  4                        -8  4      2
          t = 0.3006381635 10   n  ln(n) - 0.3477615378 10   n  ln(n)

"rel errs", [-0.6780541010, -0.7369723049, -0.1740550214, -0.2854183889,

    -0.272817898, -0.011900951, 0.172469323, -0.009576358, 0.000312382]

                         [-0.2217792576, 0.2937078494]

> 
> "lu time, no log";
                               "lu time, no log"

> foobar([[t, n], t = b*n^4, {b}], ilt);
                                               -7  4
                            t = 0.1002349652 10   n

"rel errs", [-0.9288103940, -0.9435613935, -0.8140074784, -0.8357066060,

    -0.8220866121, -0.7286498292, -0.4262629552, -0.3013981335, 0.025093910]

                         [-0.6417099436, 0.3140794857]

> "lu time, one log";
                               "lu time, one log"

> foobar([[t, n], t = b*n^4*log(n), {b}], ilt);
                                            -8  4
                         t = 0.1451440288 10   n  ln(n)

"rel errs", [-0.9596728140, -0.9680288975, -0.8915875292, -0.9042356508,

    -0.8669420314, -0.7898985997, -0.4928180595, -0.3372914149, 0.026552586]

                         [-0.6871024901, 0.3256621059]

> "lu time, one log, two term";
                          "lu time, one log, two term"

> foobar([[t, n], t = a*n^4 + b*n^4*log(n), {a,b}], ilt);
                                -7  4                  -7  4
             t = 0.9387854839 10   n  - 0.1216019588 10   n  ln(n)

"rel errs", [-0.6711109208, -0.7392591084, -0.1663041050, -0.2635686257,

    -0.448452521, -0.218809200, 0.124353674, -0.009186689, 0.000395930]

                         [-0.2657712851, 0.2834010717]

> 
#
#lpb := map(ln,pb);
#
## b = (c*n*lg(n))^a ,  lg(b) = /*lg(c)*/ + a*lg(n*lg(n)) 
#bar([[lb, n],lb = lc + a*log(n*log[2](n)), {lc, a}], lpb); 
> quit
bytes used=3119212, alloc=2620960, time=0.17
