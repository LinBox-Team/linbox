Call a vector $v$
a {\em \signature-revealing vector} for $A$ 
if $\signature(A) = \signature(v)$.
The algorithms we
propose all work by computing images of a signature revealing vector 
mod a series of primes
and constructing the integer vector via the Chinese Remainder Algorithm.
The vector will be the coefficients of the characteristic polynomial, of
the shifted minimal polynomial, or the vector of leading principal minors.
In most of these cases there can be {\em bad primes}.  For instance 
there are primes $p$ for which the minimal polynomial of image mod $p$ of $A$ 
is not the image mod $p$ of the integer minimal polynomial of $A$.  This 
leads to a shifted minpoly mod $p$ that is not a true image of the integer
shifted minpoly. Similarly
a prime may divide many leading principal minors of A (and the rank may be
lower mod $p$ than the integer rank).  Note that in both of these cases
the segment of non-zero values computed mod $p$ is shorter than it should be.
In the interest of presenting the Chinese Remaindering issues in a generic
way, we refer to a $\reveal$ function, which given $A$ and $p$, returns
a vector which is likely to be the image mod $p$ of the desired integer vector
but may not be, and if not, will be shorter.
%??? example for fake image???
We call a prime $p$ {\em good} if $\reveal(A, p)$ returns the correct image,
otherwise $p$ is {\em bad}.  

The key feature of this generic Chinese remainder algorithm for such vectors 
is its early termination technique.
%This algorithm takes a $\reveal$ fuction as an input. 
%Given input matrix $A$ and prime $p$,
%the $v_p = \reveal(A, p)$ function tries to compute the
%image of the revealing vector mod $p$, and return it.
%And the length of the output vector indicates if the output vector is 
%a correct answer: if the length of $v_p$ is equal to the length of the image of
%image of the revealing vector mod $p$, then they must be equal, 
%otherwise, the output is not correct.

\begin{algorithm} {GenCRA}\\
$[$Chinese Remainder Algorithm with early termination] 
\Inspec\\
  $A$, a symmetric integer matrix.\\
  $v_p = \reveal(A, p)$, a function as described above.\\
  $\set$, a set of primes.\\  %%with minimal prime $\minPrime$.
  $\rSize$, the random sample size for the certificate.

\Outspec\\
The revealed vector $v$ with integer coefficients. \\
%\Stmt[1.]
%$r := -1$, initially guess rank is $0$\\
\Stmt[1.]
Set list $\List := \emptyset$.  This will be a list of pairs: (good prime, imaged answer
 mod that prime).\\
Set $\length = 0$.

\Stmt[2.]
choose a random vector $x$ of length $n$ with
entries independently and uniformly chosen 
from $[0, \rSize - 1]$.
\Stmt[3.]
Uniformly and randomly remove a prime $p$ from $\set$.
%until $p$ is not used before. Mark $p$ used.\\
\Stmt[4.]
call $v_p = \reveal(A, p)$. 
If the length of $v_p$ is less than $\length$, [reject] goto statement 3.
If the length of $v_p$ is greater than $\length$, [restart] reset $\List := \{(p, v_p)\}$.
Otherwise, [continue] append pair ($p$, $v_p$) to $\List$.
\Stmt[5.]
Use Chinese remainder algorithm to construct 
the certificate $c^{(i)}$ where $i$ the size of $\List$, such that
$c^{(i)} = x \cdot v_{q} \pmod {q}$, for each pair $(q, v_q)$ in $\List$.\\
This construction is done incrementally, combining the previous result $c^{(i-1)}$ 
with the current residue and modulus.
\Stmt[6.]
If $i = 1$ or $c^{(i)} \not= c^{(i-1)}$, then goto statement 3.\\
Otherwise the termination condition, $c^{(i)} = c^{(i-1)}$,
is met.
Return the vector $v$, which is
constructed from pairs in $\List$ by the Chinese remainder algorithm,
such that $v = v_q \pmod q$, for every pair ($q, v_q$) in $\List$.
This remaindering is done using a divide-and-conquer method. 
%Quit gathering images when the termination condition is met, and 
%The Termination condition may be 
%deterministic, namely modulus greater than Hadamard bound bound,
%in which case the overall algorithm is Las Vegas.
%The Termination condition may be 
%probabilistic, namely stop by Zhendongs trick (fixme - to be explained here),
%in which case the overall algorithm is Monte Carlo.
\end{algorithm}

Notes:
\begin{enumerate}
\item
In order to capture negative numbers, 
we normalize the final number $a$ to lie in $[-(m-1)/2, (m-1)/2]$, 
where $m$=$\prod_{1\leq i \leq n} p_i$.
\item
The early termination technique which may be used to reduce the practical run time
has been studied before -see e.g. \cite{Emiris98,Kaltofen02, Eberly03}.
Here, we use a different and more efficient termination technique.
At each step, only one integer called a ``certificate" is constructed 
at each prime, instead of the entire vector answer. This method has almost
the same probability as the probability when the whole answer is constructed at each prime.  It allows the more efficient divide and conquer remaindering
to be done for the $n$ values in the answer while using the incremental
remaindering only for the certificate.
This technique can be easily adopted to other cases,
such as solving non-singular integer systems over the rationals.
%\item
%Additional independent certificates can be used to reduce the error probability,
%since the error for each independent certificate is independent.
%In our experiments, we've used two independent certificates.  
\end{enumerate}
\begin{theorem}
The algorithm above computes the revealed vector with error probability at most 
%On the condition that the length of output is correct,
%the probability that output $v$ is not correct
%is at most
\[\frac{2}{\rSize} +
\frac{\log^2_{\minPrime}(2\length \rSize B)}
{\pSize^\prime - \log_{\minPrime}(2\length \rSize B)},\]
where $B$ is the infinity norm of the correct answer,
$\pSize^\prime$ is the number of good primes in $\set$,
and $\minPrime$ is the minimal prime in $\set$.
\end{theorem}
%such that either \reveal($v_p, A, p$) returns false
%or $v_p$ has length of less than $\length$.

Note: For a typical problem, such as characteristic polynomial, 
or minimal polynomial, it is easy to choose a reasonable set of primes 
and random sample size
such that the error probability is tiny.  Runs are independent. If you
repeat the algorithm, you square the error probability.

PROOF:
Let vector $\alpha$ denote the correct answer and
$c$ denote $x \cdot \alpha$. 
We assume the early termination condition is met when 
$c^{(n)}$ is equal to $c^{(n-1)}$, for some number $n$. 
If both $\abs {c} \geq \normoo {\alpha}$ and
$c = c^{(n)}$ are true, then the algorithm returns the correct answer.
This is true since the modulus which is the product of the primes in $\List$ is at least 
$2 \normoo {\alpha}$ under these hypotheses.

If $x$ is a random vector with entries 
independently and uniformly chosen from the integer set $[0, \rSize-1]$,
then $\Prob (\abs{x \cdot \alpha}) < \normoo{\alpha})$
$\leq \frac{2}{\rSize}$.
This is true since
there is at least one entry of $\alpha$, whose absolute value is
equal to $\normoo{\alpha}$.
Without loss of generosity, we assume $\abs {\alpha_0}$ = $\normoo{\alpha}$.
Then for any $x_1, \ldots, x_{\length-1}$, then there are at most two integers $x_0$, 
such that $\abs{x \cdot \alpha} < \normoo{\alpha}$.

The probability analysis of $c \not= c^{(n)}$ 
on the condition that the early termination condition $c^{(n)} = c^{(n-1)}$ is met,
is straightforward - see e.g. \cite[Theorem 1.]{Kaltofen02} for details.
So the total error probability is at most 
$\frac{2}{\rSize} +
\frac{\log^2_{\minPrime}(2\length \rSize B)}
{\pSize^\prime - \log_{\minPrime}(2\length \rSize B)}$.
%
%Claim 2: For an integer $m$, if a random prime $p$ is uniformly chosen 
%from a cardinality $k$ subset of $\set$, then
%$\Prob(p | m) \leq \frac{\log(\abs{m})}{\log(\minPrime)k}$.
%This claim is true since there is at most $\frac{\log(\abs{m})}{\log(\minPrime)}$
%primes which are members of $\set$ and also divide $m$.
%
%When the early termination first is met at $c^{(n)} = c^{(n-1)}$,
%let us look at the probability of $c \not= c^{(n)}$.
%We have $c^{(n)} = c^{(n-1)}$, that means $c - c^{(n-1)} = 0 \pmod{p_n}$,
%and moreover, $\normoo {c - c^{(n-1)}} \leq 2\normoo{c}
%\leq 2 \length \rSize B$.
%
%For any fixed $n$, if $c \not= c^{(n-1)}$ and 
%a good prime $p_n$ is randomly uniformly chosen from $\set$,
%then $\Prob (p_n~|~(c - c^{(n-1)}))
%\leq \frac{\log_2(2\length \rSize B)}{\log(\minPrime) 
%(\pSize - \pSize^\prime - n)}$. 
%If $n$ is larger than
%$\frac{\log(2 \length \rSize B)}{\log(\minPrime)}$, 
%then $v$ must be equal to $c$.
%Since the constructed $v = c \pmod m$, and 
%$m = \prod_{1 \leq i \leq n}p_i > 2\normoo{c}$, 
%
%So when the early termination condition is met,
%$\Prob (c \not= c_{i-1}) \leq 
%\frac{(\log(2\length \rSize)^2}{(\log(\minPrime))^2 
%%(\pSize - \pSize^\prime - {\log(2 \length \rSize B)}/{\log(\minPrime)})}$.
%
%If both $\normoo{c} \geq \normoo{\alpha}$ and $c = c_n$ are true, then
%$v$ must be equal to the correct answer.
%So the  probability of
%$v \not= \alpha$ is
%at most
%$\frac{1}{\rSize}+$
%$\frac{\log^2(2\length \rSize B)^2}
%{\log^2(\minPrime) 
%(\pSize - \pSize^\prime - {\log(2 \length \rSize B)}/{\log(\minPrime)})}$.
\QED
