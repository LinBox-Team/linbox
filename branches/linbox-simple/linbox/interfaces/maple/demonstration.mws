{VERSION 5 0 "IBM INTEL LINUX" "5.0" }
{USTYLETAB {CSTYLE "Maple Input" -1 0 "Courier" 0 1 255 0 0 1 0 1 0 0 
1 0 0 0 0 1 }{CSTYLE "2D Math" -1 2 "Times" 0 1 0 0 0 0 0 0 2 0 0 0 0 
0 0 1 }{CSTYLE "2D Output" 2 20 "" 0 1 0 0 255 1 0 0 0 0 0 0 0 0 0 1 }
{CSTYLE "" -1 256 "itc avant garde" 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 }
{CSTYLE "" -1 257 "lucida bright" 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 }
{CSTYLE "" -1 258 "interface user" 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 }
{CSTYLE "" -1 259 "screen" 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 }{CSTYLE "
" -1 260 "terminal" 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 }{CSTYLE "" -1 
261 "" 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 }{CSTYLE "" -1 262 "" 0 1 0 0 
0 0 1 0 0 0 0 0 0 0 0 0 }{CSTYLE "" -1 263 "" 0 1 0 0 0 0 0 1 0 0 0 0 
0 0 0 0 }{CSTYLE "" -1 264 "" 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 }
{CSTYLE "" -1 265 "" 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 }{CSTYLE "" -1 
266 "" 0 1 0 0 0 0 1 1 0 0 0 0 0 0 0 0 }{CSTYLE "" -1 267 "" 0 1 0 0 
0 0 0 1 0 0 0 0 0 0 0 0 }{CSTYLE "" -1 268 "" 1 14 0 0 0 0 0 1 0 0 0 
0 0 0 0 0 }{CSTYLE "" -1 269 "" 1 14 0 0 0 0 0 0 0 0 0 0 0 0 0 0 }
{CSTYLE "" -1 270 "" 1 14 0 0 0 0 0 0 0 0 0 0 0 0 0 0 }{CSTYLE "" -1 
271 "" 0 24 0 0 0 0 0 1 0 0 0 0 0 0 0 0 }{CSTYLE "" -1 272 "" 1 18 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 }{CSTYLE "" -1 273 "" 1 18 0 0 0 0 0 2 0 0 
0 0 0 0 0 0 }{CSTYLE "" -1 274 "" 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 }
{CSTYLE "" -1 275 "" 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 }{CSTYLE "" -1 
276 "" 1 18 0 0 0 0 0 1 0 0 0 0 0 0 0 0 }{CSTYLE "" -1 277 "" 0 1 0 0 
0 0 0 1 0 0 0 0 0 0 0 0 }{CSTYLE "" -1 278 "" 1 18 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 }{CSTYLE "" -1 279 "" 1 18 0 0 0 0 0 1 0 0 0 0 0 0 0 0 }
{CSTYLE "" -1 280 "" 1 18 0 0 0 0 0 0 0 0 0 0 0 0 0 0 }{PSTYLE "Normal
" -1 0 1 {CSTYLE "" -1 -1 "" 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 }0 0 0 
-1 -1 -1 0 0 0 0 0 0 -1 0 }{PSTYLE "Maple Output" 0 11 1 {CSTYLE "" 
-1 -1 "" 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 }3 3 0 -1 -1 -1 0 0 0 0 0 0 
-1 0 }{PSTYLE "" 11 12 1 {CSTYLE "" -1 -1 "" 0 1 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 }1 0 0 -1 -1 -1 0 0 0 0 0 0 -1 0 }{PSTYLE "Title" 0 18 1 
{CSTYLE "" -1 -1 "" 1 18 0 0 0 0 0 1 1 0 0 0 0 0 0 0 }3 0 0 -1 12 12 
0 0 0 0 0 0 19 0 }{PSTYLE "Author" 0 19 1 {CSTYLE "" -1 -1 "" 0 1 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 }3 0 0 -1 8 8 0 0 0 0 0 0 -1 0 }{PSTYLE "" 0 
256 1 {CSTYLE "" -1 -1 "" 1 18 0 0 0 0 0 0 0 0 0 0 0 0 0 0 }0 0 0 -1 
-1 -1 0 0 0 0 0 0 -1 0 }{PSTYLE "" 0 257 1 {CSTYLE "" -1 -1 "" 0 1 0 
0 0 0 0 1 0 0 0 0 0 0 0 0 }0 0 0 -1 -1 -1 0 0 0 0 0 0 -1 0 }}
{SECT 0 {EXCHG {PARA 18 "" 0 "" {TEXT -1 0 "" }{TEXT 256 28 "Maple Lin
Box Interface, v0.5" }}{PARA 0 "" 0 "" {TEXT -1 0 "" }}{PARA 19 "" 0 "
" {TEXT -1 17 "by Rich Seagraves" }}}{EXCHG {PARA 0 "" 0 "" {TEXT -1 
271 "This interface is the fruits of a summer research project.  It is
 meant to demonstrate a practical application of the LinBox suite of u
tilities and functions.  It is currently distributed as an extra compo
nent of the LinBox development package.  Please see http://www.lin" }
{TEXT 264 0 "" }{TEXT -1 65 "alg.org to find out how to get a copy of \+
this package using CVS  " }}}{EXCHG {PARA 0 "" 0 "" {TEXT -1 259 "LinB
ox is a set of libraries meant to provide fast symbolic solutions to p
roblems in Linear Algebra.  Currently it provides solutions to 3 class
es of problems:  Rank calculations, Determinant calculations, and the \+
computation of a Matrix's Minimal Polynomial." }{TEXT 257 0 "" }{TEXT 
258 0 "" }{TEXT 259 0 "" }{TEXT 260 0 "" }}}{EXCHG {PARA 0 "" 0 "" 
{TEXT -1 0 "" }{TEXT 261 31 "Installing the LinBox interface" }}{PARA 
0 "" 0 "" {TEXT -1 335 "The interface is composed of a comiled library
 of code that wraps linbox code, and a maple script that provides Mapl
e access to this code.  To compile the library and create the script, \+
the linbox package must be compiled with the maple option activated.  \+
For information on this, see the README file  in the interfaces/maple \+
directory" }}}{EXCHG {PARA 0 "" 0 "" {TEXT -1 0 "" }{TEXT 262 0 "" }
{TEXT -1 0 "" }{TEXT 263 24 "Activating the interface" }}{PARA 0 "" 0 
"" {TEXT -1 353 "Once installation is complete, the shared object \"li
blbmaple.so\" and the maple script \"lbmaple.mpl\" will be in the $pre
fix/lib directory, where $prefix is the prefix you specified when you \+
installed LinBox .  If you want to move the interface to a different d
irectory, the lbmaple.mpl file will need to be edited.  Instructions f
or this are in the file." }}{PARA 0 "" 0 "" {TEXT -1 0 "" }}{PARA 0 "
" 0 "" {TEXT -1 145 "To activate the interface, read in the script usi
ng the following command (change $dir to the directory the interface i
s currently installed in):" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 
25 "read(\"$dir/lbmaple.mpl\");" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#7)%
(LBapplyG%1LBapplyTransposeG%&LBdetG%*LBminpolyG%'LBrankG%)LinBoxBBG%(
LinBoxVG" }}}{EXCHG {PARA 0 "" 0 "" {TEXT -1 40 "The module LinBox sho
uld be activated.  " }}}{EXCHG {PARA 0 "" 0 "" {TEXT -1 0 "" }{TEXT 
265 0 "" }{TEXT 266 0 "" }{TEXT 267 19 "Using the interface" }{TEXT 
-1 0 "" }}{PARA 0 "" 0 "" {TEXT -1 48 "The LinBox interface defines tw
o new data types:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "LinBox
BB();" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "LinBoxV();" }}}
{EXCHG {PARA 0 "" 0 "" {TEXT -1 228 "LinBoxBB is a Matrix BlackBox typ
e, while LinBoxV is a vector type.  They can be initialized with:  \n \+
                       1)  A ready made Matrix or Vector\n            \+
            2)  Dimensions and an initalization procedure" }}{PARA 0 "
" 0 "" {TEXT -1 54 "                        3)  A list (LinBoxV type o
nly)" }}{PARA 0 "" 0 "" {TEXT -1 0 "" }}{PARA 0 "" 0 "" {TEXT -1 238 "
For these data types, matrix or vector data is  stored in the external
 code so that multiple data conversions between Maple data types and e
xternal code types are un-necessary.  Each object stores a handle to a
 particular external type.  " }}{PARA 0 "" 0 "" {TEXT -1 0 "" }}{PARA 
0 "" 0 "" {TEXT -1 45 "The interface also defines several functions:" 
}}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "LBrank();" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "LBdet();" }}}{EXCHG {PARA 0 "> " 0 "
" {MPLTEXT 1 0 12 "LBminpoly();" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 
1 0 10 "LBapply();" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "LBapp
lyTranspose();" }}}{EXCHG {PARA 0 "" 0 "" {TEXT -1 175 "By default, th
ese functions expect to take the LinBox BlackBox and Vector types as i
nput.  They can take native Maple types, but convert these two the Lin
Box types on the fly." }}}{EXCHG {PARA 0 "" 0 "" {TEXT 269 0 "" }
{TEXT 268 27 "Creating a BlackBox object\n" }{TEXT -1 214 "The easiest
 way to declare a BlackBox matrix is to give the matrix a procedure an
d dimensions.  Here is a simple procedure that puts 1's on every \"eve
n\" diagonal ( abs( i-j) = 0 mod 2), and i+1 on the main diagonal" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 14 "f := proc(i,j)" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 30 "  if abs(i-j) mod 2 = 0 then 1" }}{PARA 0 "> \+
" 0 "" {MPLTEXT 1 0 8 "  else 0" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 5 " \+
 fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "end proc;" }}{PARA 11 "" 1 "
" {XPPMATH 20 "6#>%\"fGf*6$%\"iG%\"jG6\"F)F)@%/-%$modG6$-%$absG6#,&9$
\"\"\"9%!\"\"\"\"#\"\"!F4F8F)F)F)" }}}{EXCHG {PARA 0 "" 0 "" {TEXT -1 
171 "Say we want to create a 500x500 BlackBox matrix with this form.  \+
For this test, let's say we use the 30th prime.  To create the Blackbo
x, we would make the following call:" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 43 "Diag1s := LinBoxBB(ithprime(30),500,500,f);" }}{PARA 
12 "" 1 "" {XPPMATH 20 "6#>%'Diag1sG`6$%*getMatrixG%$keyGb6#%+thismodu
leG6#%)destructG6#/%'unloadGF-6$%*getMatrixG%$keyG6\"6#QDMaple~Contain
er~for~LinBox~blackboxF4F46*%\"kG%\"kG%(ExToMapG%(ExToMapG%-lbXgetMatr
ixG%-lbXgetMatrixG%.lbXkillMatrixG%.lbXkillMatrixG%,_m145668688G6#%)de
structG" }}}{EXCHG {PARA 0 "" 0 "" {TEXT -1 148 "Diag1s becomes a LinB
oxBB.  If you wanted to get a copy of the Matrix stored within the ext
ernal code, you can call the LinBoxBB method getMatrix()." }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "M := Diag1s:-getMatrix();" }}{PARA 
11 "" 1 "" {XPPMATH 20 "6#>%\"MG-%'RTABLEG6*\"*g%R\\8%)anythingG%'Matr
ixG%.Fortran_orderG7\"\"\"#;\"\"\"\"$+&F." }}}{EXCHG {PARA 0 "" 0 "" 
{TEXT -1 118 "Notice that you can also create a LinBoxBB object from a
 pre-created Matrix.  In this case, let's use the 60th, prime:" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "Diag2s := LinBoxBB(ithprime(
60), M);" }}{PARA 12 "" 1 "" {XPPMATH 20 "6#>%'Diag2sG`6$%*getMatrixG%
$keyGb6#%+thismoduleG6#%)destructG6#/%'unloadGF-6$%*getMatrixG%$keyG6
\"6#QDMaple~Container~for~LinBox~blackboxF4F46*%\"kG%\"kG%(ExToMapG%(E
xToMapG%-lbXgetMatrixG%-lbXgetMatrixG%.lbXkillMatrixG%.lbXkillMatrixG6
\"6#%)destructG" }}}{EXCHG {PARA 0 "" 0 "" {TEXT -1 2 "or" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 69 "Diag3s := LinBoxBB(ithprime(60), Ma
trix(500,500, f, storage=sparse));" }}{PARA 12 "" 1 "" {XPPMATH 20 "6#
>%'Diag3sG`6$%*getMatrixG%$keyGb6#%+thismoduleG6#%)destructG6#/%'unloa
dGF-6$%*getMatrixG%$keyG6\"6#QDMaple~Container~for~LinBox~blackboxF4F4
6*%\"kG%\"kG%(ExToMapG%(ExToMapG%-lbXgetMatrixG%-lbXgetMatrixG%.lbXkil
lMatrixG%.lbXkillMatrixG6\"6#%)destructG" }}}{EXCHG {PARA 0 "" 0 "" 
{TEXT -1 348 "Notice that the Matrix used to initalize Diag3s had the \+
option \"storage=sparse\" set.  This is a requirement of all Maple Mat
rix's used to create LinBox Blackbox types (and in general a good idea
, as LinBox works best with Sparse Matrices.  Note that any Maple Matr
ix returned by the getMatrix() method is declared to have sparse stora
ge by default." }}}{EXCHG {PARA 256 "" 0 "" {TEXT -1 0 "" }{TEXT 270 
0 "" }{TEXT 271 56 "LinBox Algorithm functions - LBrank, LBdet and LBm
inpoly" }}{PARA 0 "" 0 "" {TEXT -1 410 "Now that we've demonstrated th
e basic blackbox type, we can call LinBox functions on them.  At the p
resent, the LinBox project supports fast, probabilistic computation of
 three aspects of a Matrix:  it's Rank, it's Determinant, and it's Min
imal Polynomial.\n\nLet's say I wanted to calculate the rank of the di
agonal Matrix I created in the previous section.  To do so, I would us
e the LBrank command as follows:" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 23 "LinBox[LBrank](Diag1s);" }}{PARA 11 "" 1 "" {XPPMATH 
20 "6#\"\"#" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG 
{PARA 0 "" 0 "" {TEXT -1 73 "Let's compare that to the rank computed b
y Maple's LinearAlgebra package:" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 76 "LinearAlgebra[Rank](Matrix(500,500,f, storage=sparse,
 datatype=integer[4]));" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#\"\"#" }}}
{EXCHG {PARA 0 "" 0 "" {TEXT -1 199 "The same result.  Notice that bot
h functions gave the same result, as the rank of a Matrix is independa
nt of the entries the field over which the Matrix's entries are.  Noti
ce the timing differece - " }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 
21 "time(LBrank(Diag1s));" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#$\"$2\"!
\"$" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 61 "M := Matrix(500,500,
 f, storage=sparse, datatype=integer[4]);" }}{PARA 11 "" 1 "" 
{XPPMATH 20 "6#>%\"MG-%'RTABLEG6+\"*[XuX\"&%(integerG6#\"\"%%'MatrixG%
'sparseG%.Fortran_orderG7\"\"\"#;\"\"\"\"$+&F2" }}}{EXCHG {PARA 0 "> \+
" 0 "" {MPLTEXT 1 0 29 "time(LinearAlgebra[Rank](M));" }}{PARA 11 "" 
1 "" {XPPMATH 20 "6#$\"'X%R(!\"$" }}}{EXCHG {PARA 0 "" 0 "" {TEXT -1 
105 "Now let's look at computing the Determinant of a Matrix.  This is
 done with the LBdet command as follows:" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 14 "LBdet(Diag1s);" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#\"
\"!" }}}{EXCHG {PARA 0 "" 0 "" {TEXT -1 74 "Compare that to the Determ
inant computed by Maple's LinearAlgebra package:" }}}{EXCHG {PARA 0 ">
 " 0 "" {MPLTEXT 1 0 30 "LinearAlgebra[Determinant](M);" }}{PARA 11 "
" 1 "" {XPPMATH 20 "6#\"\"!" }}}{EXCHG {PARA 0 "" 0 "" {TEXT -1 289 "N
otice that though they both return the same number, they haven't retur
ned the same answer.  While the LinearAlgebra package's Determinant fu
nction returns the absolute Determinant, LinBox's determinant function
 returns the Modular Determinant.  The same is true of the Minimal Pol
ynomial:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "LBminpoly(Diag1
s,x);" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#,&*&\"#*)\"\"\"%\"xGF&F&*$)F'
\"\"#F&F&" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 76 "LinearAlgebra[
MinimalPolynomial](M,x); # best leave this running over-night\n" }}}
{EXCHG {PARA 0 "" 0 "" {TEXT -1 142 "You can also call LBminpoly witho
ut a symbolic argument, in which case you will recieve a Maple list of
 the coefficients, lowest degree first:" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 19 "LBminpoly(Diag1s);\n" }}{PARA 11 "" 1 "" {XPPMATH 20 
"6#7%\"\"!\"#*)\"\"\"" }}}{EXCHG {PARA 0 "" 0 "" {TEXT -1 137 "Notice \+
that the LinBox functions can be called on Maple Matrix types as well.
  When doing so, you provide the prime specifying the field:" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "LBrank(ithprime(30), M);" }}
{PARA 11 "" 1 "" {XPPMATH 20 "6#\"\"#" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 23 "LBdet(ithprime(30), M);" }}{PARA 11 "" 1 "" {XPPMATH 
20 "6#\"\"!" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "LBminpoly(it
hprime(30), M);" }{TEXT -1 0 "" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#7%\"
\"!\"#*)\"\"\"" }}}{EXCHG {PARA 0 "" 0 "" {TEXT -1 103 "In these cases
, a blackbox type is created in the background and used without return
ing a handle to it." }}}{EXCHG {PARA 257 "" 0 "" {TEXT -1 0 "" }{TEXT 
272 20 "Using LinBox Vectors" }{TEXT 273 0 "" }}{PARA 0 "" 0 "" {TEXT 
-1 0 "" }{TEXT 274 0 "" }{TEXT -1 138 "Just as a type is given to hand
le Blackbox matrices, a type has also been given to handle external Ve
ctor types.  This is the LinBoV type:" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 54 "V := LinBoxV(500, i-> if isprime(i) then 1 else 0 fi)
;" }}{PARA 12 "" 1 "" {XPPMATH 20 "6#>%\"VG`6$%*getVectorG%$keyGb6#%+t
hismoduleG6#%)destructG6#/%'unloadGF-6$%*getVectorG%$keyG6\"6#QBMaple~
container~for~LinBox~VectorF4F46*%\"kG%\"kG%.lbXkillVectorG%.lbXkillVe
ctorG%(ExToMapG%(ExToMapG%-lbXgetVectorG%-lbXgetVectorG%,_m135564960G6
#%)destructG" }}}{EXCHG {PARA 0 "" 0 "" {TEXT -1 146 "These vectors ar
e stored in external code and accessed via a key stored in the LinBoxV
 type.  The LinBoxV type can be created using the following:" }}}
{EXCHG {PARA 0 "" 0 "" {TEXT -1 44 "A length variable and procedure (s
ee above)," }}}{EXCHG {PARA 0 "" 0 "" {TEXT -1 18 "A ready-made list:
" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 41 "f := i -> if isprime(i)
 then 1 else 0 fi;" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#>%\"fGf*6#%\"iG6
\"6$%)operatorG%&arrowGF(@%-%(isprimeG6#9$\"\"\"\"\"!F(F(F(" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "V := LinBoxV([seq(f(i), i=1.
.500)]);" }{TEXT -1 0 "" }}{PARA 12 "" 1 "" {XPPMATH 20 "6#>%\"VG`6$%*
getVectorG%$keyGb6#%+thismoduleG6#%)destructG6#/%'unloadGF-6$%*getVect
orG%$keyG6\"6#QBMaple~container~for~LinBox~VectorF4F46*%\"kG%\"kG%.lbX
killVectorG%.lbXkillVectorG%(ExToMapG%(ExToMapG%-lbXgetVectorG%-lbXget
VectorG6\"6#%)destructG" }}}{EXCHG {PARA 0 "" 0 "" {TEXT -1 35 "and A \+
ready-made Maple Vector type:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 
0 83 "V := LinBoxV(Vector(500, i-> if isprime(i) then 1 else 0 fi, dat
atype=integer[4]));" }}{PARA 12 "" 1 "" {XPPMATH 20 "6#>%\"VG`6$%*getV
ectorG%$keyGb6#%+thismoduleG6#%)destructG6#/%'unloadGF-6$%*getVectorG%
$keyG6\"6#QBMaple~container~for~LinBox~VectorF4F46*%\"kG%\"kG%.lbXkill
VectorG%.lbXkillVectorG%(ExToMapG%(ExToMapG%-lbXgetVectorG%-lbXgetVect
orG%,_m135778512G6#%)destructG" }}}{EXCHG {PARA 0 "" 0 "" {TEXT -1 
167 "Notice in the last it is required that datatype=integer[4] be spe
cified.  The LinBoxV type includes a method that returns a ready made \+
Maple Vector called getVector():" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 20 "x := V:-getVector();" }}{PARA 11 "" 1 "" {XPPMATH 20 
"6#>%\"xG-%'RTABLEG6*\"*Cb5N\"%)anythingG&%'VectorG6#%'columnG%,rectan
gularG%.Fortran_orderG7\"\"\"\";F1\"$+&" }}}{EXCHG {PARA 0 "" 0 "" 
{TEXT -1 45 "x can now be used to check the contents of V;" }}}{EXCHG 
{PARA 0 "" 0 "" {TEXT -1 0 "" }{TEXT 275 0 "" }{TEXT 276 28 "LBapply a
nd LBapplyTranspose" }}{PARA 0 "" 0 "" {TEXT -1 0 "" }{TEXT 277 0 "" }
{TEXT -1 227 "The LBapply and LBapplyTranspose functions can be used t
o apply a Blackbox Matrix to an external Vector.  LBapply and LBapplyT
ranpose corresponds to the apply and applyTranspose functions in the B
lackboxArchetype.  For example:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 
1 0 25 "V1 := LBapply(Diag1s, V);" }}{PARA 12 "" 1 "" {XPPMATH 20 "6#>
%#V1G`6$%*getVectorG%$keyGb6#%+thismoduleG6#%)destructG6#/%'unloadGF-6
$%*getVectorG%$keyG6\"6#QBMaple~container~for~LinBox~VectorF4F46*%\"kG
%\"kG%.lbXkillVectorG%.lbXkillVectorG%(ExToMapG%(ExToMapG%-lbXgetVecto
rG%-lbXgetVectorG%,_m135779332G6#%)destructG" }}}{EXCHG {PARA 0 "> " 
0 "" {MPLTEXT 1 0 35 "V1T := LBapplyTranspose(Diag1s, V);" }}{PARA 12 
"" 1 "" {XPPMATH 20 "6#>%$V1TG`6$%*getVectorG%$keyGb6#%+thismoduleG6#%
)destructG6#/%'unloadGF-6$%*getVectorG%$keyG6\"6#QBMaple~container~for
~LinBox~VectorF4F46*%\"kG%\"kG%.lbXkillVectorG%.lbXkillVectorG%(ExToMa
pG%(ExToMapG%-lbXgetVectorG%-lbXgetVectorG%-_m1095974244G6#%)destructG
" }}}{EXCHG {PARA 0 "" 0 "" {TEXT -1 243 "As you can see, these functi
ons return another LinBoxV type.  As with the other functions in the L
inBox interface, LBapply and LBapplyTranspose can take Maple Matrix an
d Vector types (or a mix of LinBox and Maple types) as input.  For exa
mple:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "V2 := LBapply(ithp
rime(30), M, V);" }}{PARA 12 "" 1 "" {XPPMATH 20 "6#>%#V2G`6$%*getVect
orG%$keyGb6#%+thismoduleG6#%)destructG6#/%'unloadGF-6$%*getVectorG%$ke
yG6\"6#QBMaple~container~for~LinBox~VectorF4F46*%\"kG%\"kG%.lbXkillVec
torG%.lbXkillVectorG%(ExToMapG%(ExToMapG%-lbXgetVectorG%-lbXgetVectorG
%-_m1095975044G6#%)destructG" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 
0 102 "V3 := LBapplyTranspose(Diag1s, Vector(500, i -> if isprime(i) t
hen 1 else 0 fi, datatype=integer[4]));" }}{PARA 11 "" 1 "" {XPPMATH 
20 "6#>%#V3G-%'RTABLEG6*\"*OECN\"%)anythingG&%'VectorG6#%'columnG%,rec
tangularG%.Fortran_orderG7\"\"\"\";F1\"$+&" }}}{EXCHG {PARA 0 "> " 0 "
" {MPLTEXT 1 0 76 "vm := Vector(500, i -> if isprime(i) then 1 else 0 \+
fi, datatype=integer[4]);" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#>%#vmG-%'
RTABLEG6*\"*O5CN\"&%(integerG6#\"\"%&%'VectorG6#%'columnG%,rectangular
G%.Fortran_orderG7\"\"\"\";F4\"$+&" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 44 "V4 := LBapplyTranspose(ithprime(30), M, vm);" }}
{PARA 11 "" 1 "" {XPPMATH 20 "6#>%#V4G-%'RTABLEG6*\"*#*pLN\"%)anything
G&%'VectorG6#%'columnG%,rectangularG%.Fortran_orderG7\"\"\"\";F1\"$+&
" }}}{EXCHG {PARA 0 "" 0 "" {TEXT -1 221 "Notice in the last example, \+
the answer comes back as a Maple Vector rather than a LinBoxV type.  F
Or the LBApply and LBApplyTranspose functions, if all the inputs are M
aple types, all the outputs will also be Maple types." }}}{EXCHG 
{PARA 0 "" 0 "" {TEXT -1 226 "As always, when using a Maple Matrix wit
h a LinBox function, firsty give a prime that specifies the field of t
he Matrix.  These functions could be used to create low-level LinBox p
rocedures in Maple, were the user so inclined." }}}{EXCHG {PARA 0 "" 
0 "" {TEXT -1 0 "" }{TEXT 278 0 "" }{TEXT 279 19 "Further Development
" }{TEXT 280 0 "" }{TEXT -1 0 "" }}{PARA 0 "" 0 "" {TEXT -1 186 "As wi
th all aspects of the LinBox project, this module is currently under d
evelopment.  To aide in the development of LinBox algorithms in Maple,
 under works are the following functions:" }}}{EXCHG {PARA 0 "" 0 "" 
{TEXT -1 96 "LBdiag(prime, n) - Returns a blackbox object representing
 a diagonal Matrix with random entries." }}}{EXCHG {PARA 0 "" 0 "" 
{TEXT -1 89 "LBcompose(M1, M2) - Returns a blackbox object represeting
 the composition of two Matrices" }}}{EXCHG {PARA 0 "" 0 "" {TEXT -1 
82 "LBtranspose(M1) - Returns a blackbox object representing the trans
pose of a Matrix" }}}{EXCHG {PARA 0 "" 0 "" {TEXT -1 256 "The develope
r is currently accepting ideas, suggestions and angry flames.  If you \+
have any constructive criticism, you can reach Rich Seagraves at seagr
ave@cis.udel.edu.  Otherwise, messages pointed to /dev/null will be ju
st fine :-).  Thank you very much." }}}}{MARK "5 0 0" 10 }{VIEWOPTS 1 
1 0 1 1 1803 1 1 1 1 }{PAGENUMBERS 0 1 2 33 1 1 }
