/* -*- mode: C++; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
// vim:sts=8:sw=8:ts=8:noet:sr:cino=>s,f0,{0,g0,(0,\:0,t0,+0,=s
/* linbox/algorithms/opencl-domain.h
 * Copyright (C) 2011 Matthew Wezowicz
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor,
 * Boston, MA 02110-1301, USA.
 */

 /*###---    Generated On     ---###*/
 /*###--- 01/11/2012 18:50:32 ---###*/

#ifndef __LINBOX_opencl_matrix_domain_kernels_INL
#define __LINBOX_opencl_matrix_domain_kernels_INL

namespace LinBox{

	const char* matrixMulKernelModular1DP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
		"\n"
		"__kernel void matrixMulKernelModular1DP(__global double* C, __global double* A, __global double* B,\n"
		"		const int widthA, const int widthB, const double mod){\n"
		"	//Get Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indecies for sub-matrix of A\n"
		"	int aBegin = widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B\n"
		"	__local double As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local double Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	double Csub = 0;\n"
		"\n"
		"	//Loop over all the sub-matrices of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matrices from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Csub += As[ty][0] * Bs[0][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"		Csub += As[ty][1] * Bs[1][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"		Csub += As[ty][2] * Bs[2][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"		Csub += As[ty][3] * Bs[3][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"		Csub += As[ty][4] * Bs[4][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"		Csub += As[ty][5] * Bs[5][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"		Csub += As[ty][6] * Bs[6][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"		Csub += As[ty][7] * Bs[7][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"		Csub += As[ty][8] * Bs[8][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"		Csub += As[ty][9] * Bs[9][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"		Csub += As[ty][10] * Bs[10][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"		Csub += As[ty][11] * Bs[11][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"		Csub += As[ty][12] * Bs[12][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"		Csub += As[ty][13] * Bs[13][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"		Csub += As[ty][14] * Bs[14][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"		Csub += As[ty][15] * Bs[15][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calculates the offset in the result matrix and add the sum to the\n"
		"	//appropriate spot\n"
		"	int c = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"	C[c + ty * widthB + tx] = Csub;\n"
		"}\n"
	};

	const char* matrixMulKernelModular1SP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"\n"
		"__kernel void matrixMulKernelModular1SP(__global float* C, __global float* A, __global float* B,\n"
		"		const int widthA, const int widthB, const float mod){\n"
		"	//Get Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indecies for sub-matrix of A\n"
		"	int aBegin = widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B\n"
		"	__local float As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local float Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	float Csub = 0;\n"
		"\n"
		"	//Loop over all the sub-matrices of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matrices from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Csub += As[ty][0] * Bs[0][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"		Csub += As[ty][1] * Bs[1][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"		Csub += As[ty][2] * Bs[2][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"		Csub += As[ty][3] * Bs[3][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"		Csub += As[ty][4] * Bs[4][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"		Csub += As[ty][5] * Bs[5][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"		Csub += As[ty][6] * Bs[6][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"		Csub += As[ty][7] * Bs[7][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"		Csub += As[ty][8] * Bs[8][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"		Csub += As[ty][9] * Bs[9][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"		Csub += As[ty][10] * Bs[10][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"		Csub += As[ty][11] * Bs[11][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"		Csub += As[ty][12] * Bs[12][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"		Csub += As[ty][13] * Bs[13][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"		Csub += As[ty][14] * Bs[14][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"		Csub += As[ty][15] * Bs[15][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calculates the offset in the result matrix and add the sum to the\n"
		"	//appropriate spot\n"
		"	int c = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"	C[c + ty * widthB + tx] = Csub;\n"
		"}\n"
	};

	const char* matrixMulKernelModular8DP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
		"\n"
		"__kernel void matrixMulKernelModular8DP(__global double* C, __global double* A, __global double* B,\n"
		"		const int widthA, const int widthB, const double mod){\n"
		"	//Get Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indecies for sub-matrix of A\n"
		"	int aBegin = widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B\n"
		"	__local double As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local double Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	double Csub = 0;\n"
		"\n"
		"	//Loop over all the sub-matrices of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matrices from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Csub += As[ty][0] * Bs[0][tx];\n"
		"		Csub += As[ty][1] * Bs[1][tx];\n"
		"		Csub += As[ty][2] * Bs[2][tx];\n"
		"		Csub += As[ty][3] * Bs[3][tx];\n"
		"		Csub += As[ty][4] * Bs[4][tx];\n"
		"		Csub += As[ty][5] * Bs[5][tx];\n"
		"		Csub += As[ty][6] * Bs[6][tx];\n"
		"		Csub += As[ty][7] * Bs[7][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"\n"
		"		Csub += As[ty][8] * Bs[8][tx];\n"
		"		Csub += As[ty][9] * Bs[9][tx];\n"
		"		Csub += As[ty][10] * Bs[10][tx];\n"
		"		Csub += As[ty][11] * Bs[11][tx];\n"
		"		Csub += As[ty][12] * Bs[12][tx];\n"
		"		Csub += As[ty][13] * Bs[13][tx];\n"
		"		Csub += As[ty][14] * Bs[14][tx];\n"
		"		Csub += As[ty][15] * Bs[15][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"\n"
		"	//Calculates the offset in the result matrix and add the sum to the\n"
		"	//appropriate spot\n"
		"	int c = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"	C[c + ty * widthB + tx] = Csub;\n"
		"}\n"
	};

	const char* matrixMulKernelModular16SP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"\n"
		"__kernel void matrixMulKernelModular16SP(__global float* C, __global float* A, __global float* B,\n"
		"		const int widthA, const int widthB, const float mod){\n"
		"	//Get Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indecies for sub-matrix of A\n"
		"	int aBegin = widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B\n"
		"	__local float As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local float Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	float Csub = 0;\n"
		"\n"
		"	//Loop over all the sub-matrices of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matrices from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Csub += As[ty][0] * Bs[0][tx];\n"
		"		Csub += As[ty][1] * Bs[1][tx];\n"
		"		Csub += As[ty][2] * Bs[2][tx];\n"
		"		Csub += As[ty][3] * Bs[3][tx];\n"
		"		Csub += As[ty][4] * Bs[4][tx];\n"
		"		Csub += As[ty][5] * Bs[5][tx];\n"
		"		Csub += As[ty][6] * Bs[6][tx];\n"
		"		Csub += As[ty][7] * Bs[7][tx];\n"
		"		Csub += As[ty][8] * Bs[8][tx];\n"
		"		Csub += As[ty][9] * Bs[9][tx];\n"
		"		Csub += As[ty][10] * Bs[10][tx];\n"
		"		Csub += As[ty][11] * Bs[11][tx];\n"
		"		Csub += As[ty][12] * Bs[12][tx];\n"
		"		Csub += As[ty][13] * Bs[13][tx];\n"
		"		Csub += As[ty][14] * Bs[14][tx];\n"
		"		Csub += As[ty][15] * Bs[15][tx];\n"
		"		Csub = fmod(Csub, mod);\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"\n"
		"	//Calculates the offset in the result matrix and add the sum to the\n"
		"	//appropriate spot\n"
		"	int c = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"	C[c + ty * widthB + tx] = Csub;\n"
		"}\n"
	};

	const char* matrixMulKernelModular32DP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
		"\n"
		"__kernel void matrixMulKernelModular32DP(__global double* C, __global double* A, __global double* B,\n"
		"		const int widthA, const int widthB, const double mod){\n"
		"	//Get Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indecies for sub-matrix of A\n"
		"	int aBegin = widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B\n"
		"	__local double As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local double Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	double Csub = 0;\n"
		"\n"
		"	//Counter for modulus every 32 iterations\n"
		"	int mCount = 0;\n"
		"\n"
		"	//Loop over all the sub-matrices of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matrices from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Csub += As[ty][0] * Bs[0][tx];\n"
		"		Csub += As[ty][1] * Bs[1][tx];\n"
		"		Csub += As[ty][2] * Bs[2][tx];\n"
		"		Csub += As[ty][3] * Bs[3][tx];\n"
		"		Csub += As[ty][4] * Bs[4][tx];\n"
		"		Csub += As[ty][5] * Bs[5][tx];\n"
		"		Csub += As[ty][6] * Bs[6][tx];\n"
		"		Csub += As[ty][7] * Bs[7][tx];\n"
		"		Csub += As[ty][8] * Bs[8][tx];\n"
		"		Csub += As[ty][9] * Bs[9][tx];\n"
		"		Csub += As[ty][10] * Bs[10][tx];\n"
		"		Csub += As[ty][11] * Bs[11][tx];\n"
		"		Csub += As[ty][12] * Bs[12][tx];\n"
		"		Csub += As[ty][13] * Bs[13][tx];\n"
		"		Csub += As[ty][14] * Bs[14][tx];\n"
		"		Csub += As[ty][15] * Bs[15][tx];\n"
		"\n"
		"		mCount++;\n"
		"\n"
		"		//fmod every 32 iterations\n"
		"		if(mCount == 2){\n"
		"			Csub = fmod(Csub, mod);\n"
		"			mCount = 0;\n"
		"		}\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calls fmod once to normalize the sum\n"
		"	Csub = fmod(Csub, mod);\n"
		"\n"
		"	//Calculates the offset in the result matrix and add the sum to the\n"
		"	//appropriate spot\n"
		"	int c = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"	C[c + ty * widthB + tx] = Csub;\n"
		"}\n"
	};

	const char* matrixMulKernelModular32SP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"\n"
		"__kernel void matrixMulKernelModular32SP(__global float* C, __global float* A, __global float* B,\n"
		"		const int widthA, const int widthB, const float mod){\n"
		"	//Get Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indecies for sub-matrix of A\n"
		"	int aBegin = widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B\n"
		"	__local float As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local float Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	float Csub = 0;\n"
		"\n"
		"	//Counter for modulus every 32 iterations\n"
		"	int mCount = 0;\n"
		"\n"
		"	//Loop over all the sub-matrices of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matrices from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Csub += As[ty][0] * Bs[0][tx];\n"
		"		Csub += As[ty][1] * Bs[1][tx];\n"
		"		Csub += As[ty][2] * Bs[2][tx];\n"
		"		Csub += As[ty][3] * Bs[3][tx];\n"
		"		Csub += As[ty][4] * Bs[4][tx];\n"
		"		Csub += As[ty][5] * Bs[5][tx];\n"
		"		Csub += As[ty][6] * Bs[6][tx];\n"
		"		Csub += As[ty][7] * Bs[7][tx];\n"
		"		Csub += As[ty][8] * Bs[8][tx];\n"
		"		Csub += As[ty][9] * Bs[9][tx];\n"
		"		Csub += As[ty][10] * Bs[10][tx];\n"
		"		Csub += As[ty][11] * Bs[11][tx];\n"
		"		Csub += As[ty][12] * Bs[12][tx];\n"
		"		Csub += As[ty][13] * Bs[13][tx];\n"
		"		Csub += As[ty][14] * Bs[14][tx];\n"
		"		Csub += As[ty][15] * Bs[15][tx];\n"
		"\n"
		"		mCount++;\n"
		"\n"
		"		//fmod every 32 iterations\n"
		"		if(mCount == 2){\n"
		"			Csub = fmod(Csub, mod);\n"
		"			mCount = 0;\n"
		"		}\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calls fmod once to normalize the sum\n"
		"	Csub = fmod(Csub, mod);\n"
		"\n"
		"	//Calculates the offset in the result matrix and add the sum to the\n"
		"	//appropriate spot\n"
		"	int c = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"	C[c + ty * widthB + tx] = Csub;\n"
		"}\n"
	};

	const char* matrixMulKernelModular1024DP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
		"\n"
		"__kernel void matrixMulKernelModular1024DP(__global double* C, __global double* A, __global double* B,\n"
		"		const int widthA, const int widthB, const double mod){\n"
		"	//Get Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indecies for sub-matrix of A\n"
		"	int aBegin = widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B\n"
		"	__local double As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local double Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	double Csub = 0;\n"
		"\n"
		"	//Counter for modulus every 32 iterations\n"
		"	int mCount = 0;\n"
		"\n"
		"	//Loop over all the sub-matrices of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matrices from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Csub += As[ty][0] * Bs[0][tx];\n"
		"		Csub += As[ty][1] * Bs[1][tx];\n"
		"		Csub += As[ty][2] * Bs[2][tx];\n"
		"		Csub += As[ty][3] * Bs[3][tx];\n"
		"		Csub += As[ty][4] * Bs[4][tx];\n"
		"		Csub += As[ty][5] * Bs[5][tx];\n"
		"		Csub += As[ty][6] * Bs[6][tx];\n"
		"		Csub += As[ty][7] * Bs[7][tx];\n"
		"		Csub += As[ty][8] * Bs[8][tx];\n"
		"		Csub += As[ty][9] * Bs[9][tx];\n"
		"		Csub += As[ty][10] * Bs[10][tx];\n"
		"		Csub += As[ty][11] * Bs[11][tx];\n"
		"		Csub += As[ty][12] * Bs[12][tx];\n"
		"		Csub += As[ty][13] * Bs[13][tx];\n"
		"		Csub += As[ty][14] * Bs[14][tx];\n"
		"		Csub += As[ty][15] * Bs[15][tx];\n"
		"\n"
		"		mCount++;\n"
		"\n"
		"		//fmod every 1024 iterations\n"
		"		if(mCount == 64){\n"
		"			Csub = fmod(Csub, mod);\n"
		"			mCount = 0;\n"
		"		}\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calls fmod once to normalize the sum\n"
		"	Csub = fmod(Csub, mod);\n"
		"\n"
		"	//Calculates the offset in the result matrix and add the sum to the\n"
		"	//appropriate spot\n"
		"	int c = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"	C[c + ty * widthB + tx] = Csub;\n"
		"}\n"
	};

	const char* matrixMulKernelModular1024SP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"\n"
		"__kernel void matrixMulKernelModular1024SP(__global float* C, __global float* A, __global float* B,\n"
		"		const int widthA, const int widthB, const float mod){\n"
		"	//Get Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indecies for sub-matrix of A\n"
		"	int aBegin = widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B\n"
		"	__local float As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local float Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	float Csub = 0;\n"
		"\n"
		"	//Counter for modulus every 32 iterations\n"
		"	int mCount = 0;\n"
		"\n"
		"	//Loop over all the sub-matrices of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matrices from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Csub += As[ty][0] * Bs[0][tx];\n"
		"		Csub += As[ty][1] * Bs[1][tx];\n"
		"		Csub += As[ty][2] * Bs[2][tx];\n"
		"		Csub += As[ty][3] * Bs[3][tx];\n"
		"		Csub += As[ty][4] * Bs[4][tx];\n"
		"		Csub += As[ty][5] * Bs[5][tx];\n"
		"		Csub += As[ty][6] * Bs[6][tx];\n"
		"		Csub += As[ty][7] * Bs[7][tx];\n"
		"		Csub += As[ty][8] * Bs[8][tx];\n"
		"		Csub += As[ty][9] * Bs[9][tx];\n"
		"		Csub += As[ty][10] * Bs[10][tx];\n"
		"		Csub += As[ty][11] * Bs[11][tx];\n"
		"		Csub += As[ty][12] * Bs[12][tx];\n"
		"		Csub += As[ty][13] * Bs[13][tx];\n"
		"		Csub += As[ty][14] * Bs[14][tx];\n"
		"		Csub += As[ty][15] * Bs[15][tx];\n"
		"\n"
		"		mCount++;\n"
		"\n"
		"		//fmod every 1024 iterations\n"
		"		if(mCount == 64){\n"
		"			Csub = fmod(Csub, mod);\n"
		"			mCount = 0;\n"
		"		}\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calls fmod once to normalize the sum\n"
		"	Csub = fmod(Csub, mod);\n"
		"\n"
		"	//Calculates the offset in the result matrix and add the sum to the\n"
		"	//appropriate spot\n"
		"	int c = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"	C[c + ty * widthB + tx] = Csub;\n"
		"}\n"
	};

	const char* matrixMuladdKernelModular1DP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
		"\n"
		"__kernel void matrixMuladdKernelModular1DP(__global double* D, double alpha, __global double* A, __global double* B,\n"
		"		double beta, __global double* C, const int widthA, const int widthB, const double mod){\n"
		"	//Get Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indecies for sub-matrix of A\n"
		"	int aBegin = widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B\n"
		"	__local double As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local double Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	double Dsub = 0;\n"
		"\n"
		"	//Loop over all the sub-matrices of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matrices from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Dsub += As[ty][0] * Bs[0][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][1] * Bs[1][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][2] * Bs[2][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][3] * Bs[3][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][4] * Bs[4][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][5] * Bs[5][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][6] * Bs[6][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][7] * Bs[7][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][8] * Bs[8][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][9] * Bs[9][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][10] * Bs[10][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][11] * Bs[11][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][12] * Bs[12][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][13] * Bs[13][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][14] * Bs[14][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][15] * Bs[15][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calculates the offset in the result matrix\n"
		"	int d = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"\n"
		"	//Scale Dsub by alpha\n"
		"	Dsub = alpha * Dsub;\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"	if(Dsub < 0){\n"
		"		Dsub = mod + Dsub;\n"
		"	}\n"
		"\n"
		"	//Scalse Csub by beta\n"
		"	double Csub = C[d + ty * widthB + tx];\n"
		"	Csub = beta * Csub;\n"
		"	Csub = fmod(Csub, mod);\n"
		"	if(Csub < 0){\n"
		"		Csub = mod + Csub;\n"
		"	}\n"
		"\n"
		"	//Add Dsub and Dsub\n"
		"	Dsub = Dsub + Csub;\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"\n"
		"	//Add the sum to the appropriate spot\n"
		"	D[d + ty * widthB + tx] = Dsub;\n"
		"}\n"
	};

	const char* matrixMuladdKernelModular1SP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"\n"
		"__kernel void matrixMuladdKernelModular1SP(__global float* D, float alpha, __global float* A, __global float* B,\n"
		"		float beta, __global float* C, const int widthA, const int widthB, const float mod){\n"
		"	//Get Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indecies for sub-matrix of A\n"
		"	int aBegin = widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B\n"
		"	__local float As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local float Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	float Dsub = 0;\n"
		"\n"
		"	//Loop over all the sub-matrices of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matrices from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Dsub += As[ty][0] * Bs[0][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][1] * Bs[1][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][2] * Bs[2][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][3] * Bs[3][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][4] * Bs[4][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][5] * Bs[5][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][6] * Bs[6][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][7] * Bs[7][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][8] * Bs[8][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][9] * Bs[9][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][10] * Bs[10][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][11] * Bs[11][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][12] * Bs[12][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][13] * Bs[13][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][14] * Bs[14][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][15] * Bs[15][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calculates the offset in the result matrix\n"
		"	int d = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"\n"
		"	//Scale Dsub by alpha\n"
		"	Dsub = alpha * Dsub;\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"	if(Dsub < 0){\n"
		"		Dsub = mod + Dsub;\n"
		"	}\n"
		"\n"
		"	//Scalse Csub by beta\n"
		"	float Csub = C[d + ty * widthB + tx];\n"
		"	Csub = beta * Csub;\n"
		"	Csub = fmod(Csub, mod);\n"
		"	if(Csub < 0){\n"
		"		Csub = mod + Csub;\n"
		"	}\n"
		"\n"
		"	//Add Dsub and Dsub\n"
		"	Dsub = Dsub + Csub;\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"\n"
		"	//Add the sum to the appropriate spot\n"
		"	D[d + ty * widthB + tx] = Dsub;\n"
		"}\n"
	};

	const char* matrixMuladdKernelModular8DP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
		"\n"
		"__kernel void matrixMuladdKernelModular8DP(__global double* D, double alpha, __global double* A, __global double* B,\n"
		"		double beta, __global double* C, const int widthA, const int widthB, const double mod){\n"
		"	//Get Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indecies for sub-matrix of A\n"
		"	int aBegin = widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B\n"
		"	__local double As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local double Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	double Dsub = 0;\n"
		"\n"
		"	//Loop over all the sub-matrices of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matrices from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Dsub += As[ty][0] * Bs[0][tx];\n"
		"		Dsub += As[ty][1] * Bs[1][tx];\n"
		"		Dsub += As[ty][2] * Bs[2][tx];\n"
		"		Dsub += As[ty][3] * Bs[3][tx];\n"
		"		Dsub += As[ty][4] * Bs[4][tx];\n"
		"		Dsub += As[ty][5] * Bs[5][tx];\n"
		"		Dsub += As[ty][6] * Bs[6][tx];\n"
		"		Dsub += As[ty][7] * Bs[7][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"\n"
		"		Dsub += As[ty][8] * Bs[8][tx];\n"
		"		Dsub += As[ty][9] * Bs[9][tx];\n"
		"		Dsub += As[ty][10] * Bs[10][tx];\n"
		"		Dsub += As[ty][11] * Bs[11][tx];\n"
		"		Dsub += As[ty][12] * Bs[12][tx];\n"
		"		Dsub += As[ty][13] * Bs[13][tx];\n"
		"		Dsub += As[ty][14] * Bs[14][tx];\n"
		"		Dsub += As[ty][15] * Bs[15][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calculates the offset in the result matrix\n"
		"	int d = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"\n"
		"	//Scale Dsub by alpha\n"
		"	Dsub = alpha * Dsub;\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"	if(Dsub < 0){\n"
		"		Dsub = mod + Dsub;\n"
		"	}\n"
		"\n"
		"	//Scalse Csub by beta\n"
		"	double Csub = C[d + ty * widthB + tx];\n"
		"	Csub = beta * Csub;\n"
		"	Csub = fmod(Csub, mod);\n"
		"	if(Csub < 0){\n"
		"		Csub = mod + Csub;\n"
		"	}\n"
		"\n"
		"	//Add Dsub and Dsub\n"
		"	Dsub = Dsub + Csub;\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"\n"
		"	//Add the sum to the appropriate spot\n"
		"	D[d + ty * widthB + tx] = Dsub;\n"
		"}\n"
	};

	const char* matrixMuladdKernelModular16SP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"\n"
		"__kernel void matrixMuladdKernelModular16SP(__global float* D, float alpha, __global float* A, __global float* B,\n"
		"		float beta, __global float* C, const int widthA, const int widthB, const float mod){\n"
		"	//Get Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indecies for sub-matrix of A\n"
		"	int aBegin = widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B\n"
		"	__local float As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local float Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	float Dsub = 0;\n"
		"\n"
		"	//Setup count for modulus every 32 iterations.\n"
		"	int m = 0;\n"
		"\n"
		"	//Loop over all the sub-matrices of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matrices from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Dsub += As[ty][0] * Bs[0][tx];\n"
		"		Dsub += As[ty][1] * Bs[1][tx];\n"
		"		Dsub += As[ty][2] * Bs[2][tx];\n"
		"		Dsub += As[ty][3] * Bs[3][tx];\n"
		"		Dsub += As[ty][4] * Bs[4][tx];\n"
		"		Dsub += As[ty][5] * Bs[5][tx];\n"
		"		Dsub += As[ty][6] * Bs[6][tx];\n"
		"		Dsub += As[ty][7] * Bs[7][tx];\n"
		"		Dsub += As[ty][8] * Bs[8][tx];\n"
		"		Dsub += As[ty][9] * Bs[9][tx];\n"
		"		Dsub += As[ty][10] * Bs[10][tx];\n"
		"		Dsub += As[ty][11] * Bs[11][tx];\n"
		"		Dsub += As[ty][12] * Bs[12][tx];\n"
		"		Dsub += As[ty][13] * Bs[13][tx];\n"
		"		Dsub += As[ty][14] * Bs[14][tx];\n"
		"		Dsub += As[ty][15] * Bs[15][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calculates the offset in the result matrix\n"
		"	int d = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"\n"
		"	//Scale Dsub by alpha\n"
		"	Dsub = alpha * Dsub;\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"	if(Dsub < 0){\n"
		"		Dsub = mod + Dsub;\n"
		"	}\n"
		"\n"
		"	//Scalse Csub by beta\n"
		"	float Csub = C[d + ty * widthB + tx];\n"
		"	Csub = beta * Csub;\n"
		"	Csub = fmod(Csub, mod);\n"
		"	if(Csub < 0){\n"
		"		Csub = mod + Csub;\n"
		"	}\n"
		"\n"
		"	//Add Dsub and Dsub\n"
		"	Dsub = Dsub + Csub;\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"\n"
		"	//Add the sum to the appropriate spot\n"
		"	D[d + ty * widthB + tx] = Dsub;\n"
		"}\n"
	};

	const char* matrixMuladdKernelModular32DP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
		"\n"
		"__kernel void matrixMuladdKernelModular32DP(__global double* D, double alpha, __global double* A, __global double* B,\n"
		"		double beta, __global double* C, const int widthA, const int widthB, const double mod){\n"
		"	//Get Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indecies for sub-matrix of A\n"
		"	int aBegin = widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B\n"
		"	__local double As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local double Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	double Dsub = 0;\n"
		"\n"
		"	//Counter for modulus every 32 iterations\n"
		"	int mCount = 0;\n"
		"\n"
		"	//Loop over all the sub-matrices of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matrices from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Dsub += As[ty][0] * Bs[0][tx];\n"
		"		Dsub += As[ty][1] * Bs[1][tx];\n"
		"		Dsub += As[ty][2] * Bs[2][tx];\n"
		"		Dsub += As[ty][3] * Bs[3][tx];\n"
		"		Dsub += As[ty][4] * Bs[4][tx];\n"
		"		Dsub += As[ty][5] * Bs[5][tx];\n"
		"		Dsub += As[ty][6] * Bs[6][tx];\n"
		"		Dsub += As[ty][7] * Bs[7][tx];\n"
		"		Dsub += As[ty][8] * Bs[8][tx];\n"
		"		Dsub += As[ty][9] * Bs[9][tx];\n"
		"		Dsub += As[ty][10] * Bs[10][tx];\n"
		"		Dsub += As[ty][11] * Bs[11][tx];\n"
		"		Dsub += As[ty][12] * Bs[12][tx];\n"
		"		Dsub += As[ty][13] * Bs[13][tx];\n"
		"		Dsub += As[ty][14] * Bs[14][tx];\n"
		"		Dsub += As[ty][15] * Bs[15][tx];\n"
		"\n"
		"		mCount++;\n"
		"\n"
		"		//fmod every 32 iterations\n"
		"		if(mCount == 2){\n"
		"			Dsub = fmod(Dsub, mod);\n"
		"			mCount = 0;\n"
		"		}\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"\n"
		"	//Calculates the offset in the result matrix\n"
		"	int d = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"\n"
		"	//Scale Dsub by alpha\n"
		"	Dsub = alpha * Dsub;\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"	if(Dsub < 0){\n"
		"		Dsub = mod + Dsub;\n"
		"	}\n"
		"\n"
		"	//Scalse Csub by beta\n"
		"	double Csub = C[d + ty * widthB + tx];\n"
		"	Csub = beta * Csub;\n"
		"	Csub = fmod(Csub, mod);\n"
		"	if(Csub < 0){\n"
		"		Csub = mod + Csub;\n"
		"	}\n"
		"\n"
		"	//Add Dsub and Dsub\n"
		"	Dsub = Dsub + Csub;\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"\n"
		"	//Add the sum to the appropriate spot\n"
		"	D[d + ty * widthB + tx] = Dsub;\n"
		"}\n"
	};

	const char* matrixMuladdKernelModular32SP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"\n"
		"__kernel void matrixMuladdKernelModular32SP(__global float* D, float alpha, __global float* A, __global float* B,\n"
		"		float beta, __global float* C, const int widthA, const int widthB, const float mod){\n"
		"	//Get Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indecies for sub-matrix of A\n"
		"	int aBegin = widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B\n"
		"	__local float As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local float Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	float Dsub = 0;\n"
		"\n"
		"	//Counter for modulus every 32 iterations\n"
		"	int mCount = 0;\n"
		"\n"
		"	//Loop over all the sub-matrices of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matrices from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Dsub += As[ty][0] * Bs[0][tx];\n"
		"		Dsub += As[ty][1] * Bs[1][tx];\n"
		"		Dsub += As[ty][2] * Bs[2][tx];\n"
		"		Dsub += As[ty][3] * Bs[3][tx];\n"
		"		Dsub += As[ty][4] * Bs[4][tx];\n"
		"		Dsub += As[ty][5] * Bs[5][tx];\n"
		"		Dsub += As[ty][6] * Bs[6][tx];\n"
		"		Dsub += As[ty][7] * Bs[7][tx];\n"
		"		Dsub += As[ty][8] * Bs[8][tx];\n"
		"		Dsub += As[ty][9] * Bs[9][tx];\n"
		"		Dsub += As[ty][10] * Bs[10][tx];\n"
		"		Dsub += As[ty][11] * Bs[11][tx];\n"
		"		Dsub += As[ty][12] * Bs[12][tx];\n"
		"		Dsub += As[ty][13] * Bs[13][tx];\n"
		"		Dsub += As[ty][14] * Bs[14][tx];\n"
		"		Dsub += As[ty][15] * Bs[15][tx];\n"
		"\n"
		"		mCount++;\n"
		"\n"
		"		//fmod every 32 iterations\n"
		"		if(mCount == 2){\n"
		"			Dsub = fmod(Dsub, mod);\n"
		"			mCount = 0;\n"
		"		}\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"\n"
		"	//Calculates the offset in the result matrix\n"
		"	int d = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"\n"
		"	//Scale Dsub by alpha\n"
		"	Dsub = alpha * Dsub;\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"	if(Dsub < 0){\n"
		"		Dsub = mod + Dsub;\n"
		"	}\n"
		"\n"
		"	//Scalse Csub by beta\n"
		"	float Csub = C[d + ty * widthB + tx];\n"
		"	Csub = beta * Csub;\n"
		"	Csub = fmod(Csub, mod);\n"
		"	if(Csub < 0){\n"
		"		Csub = mod + Csub;\n"
		"	}\n"
		"\n"
		"	//Add Dsub and Dsub\n"
		"	Dsub = Dsub + Csub;\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"\n"
		"	//Add the sum to the appropriate spot\n"
		"	D[d + ty * widthB + tx] = Dsub;\n"
		"}\n"
	};

	const char* matrixMuladdKernelModular1024DP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
		"\n"
		"__kernel void matrixMuladdKernelModular1024DP(__global double* D, double alpha, __global double* A, __global double* B,\n"
		"		double beta, __global double* C, const int widthA, const int widthB, const double mod){\n"
		"	//Get Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indecies for sub-matrix of A\n"
		"	int aBegin = widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B\n"
		"	__local double As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local double Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	double Dsub = 0;\n"
		"\n"
		"	//Counter for modulus every 32 iterations\n"
		"	int mCount = 0;\n"
		"\n"
		"	//Loop over all the sub-matrices of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matrices from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Dsub += As[ty][0] * Bs[0][tx];\n"
		"		Dsub += As[ty][1] * Bs[1][tx];\n"
		"		Dsub += As[ty][2] * Bs[2][tx];\n"
		"		Dsub += As[ty][3] * Bs[3][tx];\n"
		"		Dsub += As[ty][4] * Bs[4][tx];\n"
		"		Dsub += As[ty][5] * Bs[5][tx];\n"
		"		Dsub += As[ty][6] * Bs[6][tx];\n"
		"		Dsub += As[ty][7] * Bs[7][tx];\n"
		"		Dsub += As[ty][8] * Bs[8][tx];\n"
		"		Dsub += As[ty][9] * Bs[9][tx];\n"
		"		Dsub += As[ty][10] * Bs[10][tx];\n"
		"		Dsub += As[ty][11] * Bs[11][tx];\n"
		"		Dsub += As[ty][12] * Bs[12][tx];\n"
		"		Dsub += As[ty][13] * Bs[13][tx];\n"
		"		Dsub += As[ty][14] * Bs[14][tx];\n"
		"		Dsub += As[ty][15] * Bs[15][tx];\n"
		"\n"
		"		mCount++;\n"
		"\n"
		"		//fmod every 1024 iterations\n"
		"		if(mCount == 64){\n"
		"			Dsub = fmod(Dsub, mod);\n"
		"			mCount = 0;\n"
		"		}\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"\n"
		"	//Calculates the offset in the result matrix\n"
		"	int d = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"\n"
		"	//Scale Dsub by alpha\n"
		"	Dsub = alpha * Dsub;\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"	if(Dsub < 0){\n"
		"		Dsub = mod + Dsub;\n"
		"	}\n"
		"\n"
		"	//Scalse Csub by beta\n"
		"	double Csub = C[d + ty * widthB + tx];\n"
		"	Csub = beta * Csub;\n"
		"	Csub = fmod(Csub, mod);\n"
		"	if(Csub < 0){\n"
		"		Csub = mod + Csub;\n"
		"	}\n"
		"\n"
		"	//Add Dsub and Dsub\n"
		"	Dsub = Dsub + Csub;\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"\n"
		"	//Add the sum to the appropriate spot\n"
		"	D[d + ty * widthB + tx] = Dsub;\n"
		"}\n"
	};

	const char* matrixMuladdKernelModular1024SP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"\n"
		"__kernel void matrixMuladdKernelModular1024SP(__global float* D, float alpha, __global float* A, __global float* B,\n"
		"		float beta, __global float* C, const int widthA, const int widthB, const float mod){\n"
		"	//Get Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indecies for sub-matrix of A\n"
		"	int aBegin = widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B\n"
		"	__local float As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local float Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	float Dsub = 0;\n"
		"\n"
		"	//Counter for modulus every 32 iterations\n"
		"	int mCount = 0;\n"
		"\n"
		"	//Loop over all the sub-matrices of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matrices from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Dsub += As[ty][0] * Bs[0][tx];\n"
		"		Dsub += As[ty][1] * Bs[1][tx];\n"
		"		Dsub += As[ty][2] * Bs[2][tx];\n"
		"		Dsub += As[ty][3] * Bs[3][tx];\n"
		"		Dsub += As[ty][4] * Bs[4][tx];\n"
		"		Dsub += As[ty][5] * Bs[5][tx];\n"
		"		Dsub += As[ty][6] * Bs[6][tx];\n"
		"		Dsub += As[ty][7] * Bs[7][tx];\n"
		"		Dsub += As[ty][8] * Bs[8][tx];\n"
		"		Dsub += As[ty][9] * Bs[9][tx];\n"
		"		Dsub += As[ty][10] * Bs[10][tx];\n"
		"		Dsub += As[ty][11] * Bs[11][tx];\n"
		"		Dsub += As[ty][12] * Bs[12][tx];\n"
		"		Dsub += As[ty][13] * Bs[13][tx];\n"
		"		Dsub += As[ty][14] * Bs[14][tx];\n"
		"		Dsub += As[ty][15] * Bs[15][tx];\n"
		"\n"
		"		mCount++;\n"
		"\n"
		"		//fmod every 1024 iterations\n"
		"		if(mCount == 64){\n"
		"			Dsub = fmod(Dsub, mod);\n"
		"			mCount = 0;\n"
		"		}\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"\n"
		"	//Calculates the offset in the result matrix\n"
		"	int d = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"\n"
		"	//Scale Dsub by alpha\n"
		"	Dsub = alpha * Dsub;\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"	if(Dsub < 0){\n"
		"		Dsub = mod + Dsub;\n"
		"	}\n"
		"\n"
		"	//Scalse Csub by beta\n"
		"	float Csub = C[d + ty * widthB + tx];\n"
		"	Csub = beta * Csub;\n"
		"	Csub = fmod(Csub, mod);\n"
		"	if(Csub < 0){\n"
		"		Csub = mod + Csub;\n"
		"	}\n"
		"\n"
		"	//Add Dsub and Dsub\n"
		"	Dsub = Dsub + Csub;\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"\n"
		"	//Add the sum to the appropriate spot\n"
		"	D[d + ty * widthB + tx] = Dsub;\n"
		"}\n"
	};

	const char* matrixAxpyKernelModular1DP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
		"\n"
		"__kernel void matrixAxpyKernelModular1DP(__global double* D, __global double* A, __global double* B,\n"
		"		__global double* C, const int widthA, const int widthB, const double mod){\n"
		"	//Geet Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indexies for submatrix of A\n"
		"	int aBegin= widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B;\n"
		"	__local double As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local double Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	double Dsub = 0;\n"
		"\n"
		"	//Loop over all the sub-maticies of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matricies from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Dsub += As[ty][0] * Bs[0][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][1] * Bs[1][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][2] * Bs[2][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][3] * Bs[3][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][4] * Bs[4][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][5] * Bs[5][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][6] * Bs[6][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][7] * Bs[7][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][8] * Bs[8][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][9] * Bs[9][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][10] * Bs[10][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][11] * Bs[11][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][12] * Bs[12][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][13] * Bs[13][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][14] * Bs[14][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][15] * Bs[15][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calculates the offset inthe result matrix\n"
		"	int d = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"\n"
		"	//Load, add, and normalize with element from C\n"
		"	double c = C[d + ty * widthB + tx];\n"
		"	Dsub = Dsub + c;\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"\n"
		"	//Add the sum to the appropriate spot\n"
		"	D[d + ty * widthB + tx] = Dsub;\n"
		"}\n"
	};

	const char* matrixAxpyKernelModular1SP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"\n"
		"__kernel void matrixAxpyKernelModular1SP(__global float* D, __global float* A, __global float* B,\n"
		"		__global float* C, const int widthA, const int widthB, const float mod){\n"
		"	//Geet Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indexies for submatrix of A\n"
		"	int aBegin= widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B;\n"
		"	__local float As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local float Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	float Dsub = 0;\n"
		"\n"
		"	//Loop over all the sub-maticies of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matricies from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Dsub += As[ty][0] * Bs[0][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][1] * Bs[1][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][2] * Bs[2][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][3] * Bs[3][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][4] * Bs[4][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][5] * Bs[5][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][6] * Bs[6][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][7] * Bs[7][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][8] * Bs[8][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][9] * Bs[9][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][10] * Bs[10][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][11] * Bs[11][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][12] * Bs[12][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][13] * Bs[13][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][14] * Bs[14][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][15] * Bs[15][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calculates the offset inthe result matrix\n"
		"	int d = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"\n"
		"	//Load, add, and normalize with element from C\n"
		"	float c = C[d + ty * widthB + tx];\n"
		"	Dsub = Dsub + c;\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"\n"
		"	//Add the sum to the appropriate spot\n"
		"	D[d + ty * widthB + tx] = Dsub;\n"
		"}\n"
	};

	const char* matrixAxpyKernelModular8DP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
		"\n"
		"__kernel void matrixAxpyKernelModular8DP(__global double* D, __global double* A, __global double* B,\n"
		"		__global double* C, const int widthA, const int widthB, const double mod){\n"
		"	//Geet Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indexies for submatrix of A\n"
		"	int aBegin= widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B;\n"
		"	__local double As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local double Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	double Dsub = 0;\n"
		"\n"
		"	//Loop over all the sub-maticies of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matricies from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Dsub += As[ty][0] * Bs[0][tx];\n"
		"		Dsub += As[ty][1] * Bs[1][tx];\n"
		"		Dsub += As[ty][2] * Bs[2][tx];\n"
		"		Dsub += As[ty][3] * Bs[3][tx];\n"
		"		Dsub += As[ty][4] * Bs[4][tx];\n"
		"		Dsub += As[ty][5] * Bs[5][tx];\n"
		"		Dsub += As[ty][6] * Bs[6][tx];\n"
		"		Dsub += As[ty][7] * Bs[7][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"\n"
		"		Dsub += As[ty][8] * Bs[8][tx];\n"
		"		Dsub += As[ty][9] * Bs[9][tx];\n"
		"		Dsub += As[ty][10] * Bs[10][tx];\n"
		"		Dsub += As[ty][11] * Bs[11][tx];\n"
		"		Dsub += As[ty][12] * Bs[12][tx];\n"
		"		Dsub += As[ty][13] * Bs[13][tx];\n"
		"		Dsub += As[ty][14] * Bs[14][tx];\n"
		"		Dsub += As[ty][15] * Bs[15][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calculates the offset inthe result matrix\n"
		"	int d = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"\n"
		"	//Load, add, and normalize with element from C\n"
		"	double c = C[d + ty * widthB + tx];\n"
		"	Dsub = Dsub + c;\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"\n"
		"	//Add the sum to the appropriate spot\n"
		"	D[d + ty * widthB + tx] = Dsub;\n"
		"}\n"
	};

	const char* matrixAxpyKernelModular16SP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"\n"
		"__kernel void matrixAxpyKernelModular16SP(__global float* D, __global float* A, __global float* B,\n"
		"		__global float* C, const int widthA, const int widthB, const float mod){\n"
		"	//Geet Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indexies for submatrix of A\n"
		"	int aBegin= widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B;\n"
		"	__local float As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local float Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	float Dsub = 0;\n"
		"\n"
		"	//Loop over all the sub-maticies of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matricies from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Dsub += As[ty][0] * Bs[0][tx];\n"
		"		Dsub += As[ty][1] * Bs[1][tx];\n"
		"		Dsub += As[ty][2] * Bs[2][tx];\n"
		"		Dsub += As[ty][3] * Bs[3][tx];\n"
		"		Dsub += As[ty][4] * Bs[4][tx];\n"
		"		Dsub += As[ty][5] * Bs[5][tx];\n"
		"		Dsub += As[ty][6] * Bs[6][tx];\n"
		"		Dsub += As[ty][7] * Bs[7][tx];\n"
		"		Dsub += As[ty][8] * Bs[8][tx];\n"
		"		Dsub += As[ty][9] * Bs[9][tx];\n"
		"		Dsub += As[ty][10] * Bs[10][tx];\n"
		"		Dsub += As[ty][11] * Bs[11][tx];\n"
		"		Dsub += As[ty][12] * Bs[12][tx];\n"
		"		Dsub += As[ty][13] * Bs[13][tx];\n"
		"		Dsub += As[ty][14] * Bs[14][tx];\n"
		"		Dsub += As[ty][15] * Bs[15][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calculates the offset inthe result matrix\n"
		"	int d = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"\n"
		"	//Load, add, and normalize with element from C\n"
		"	float c = C[d + ty * widthB + tx];\n"
		"	Dsub = Dsub + c;\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"\n"
		"	//Add the sum to the appropriate spot\n"
		"	D[d + ty * widthB + tx] = Dsub;\n"
		"}\n"
	};

	const char* matrixAxpyKernelModular32DP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
		"\n"
		"__kernel void matrixAxpyKernelModular32DP(__global double* D, __global double* A, __global double* B,\n"
		"		__global double* C, const int widthA, const int widthB, const double mod){\n"
		"	//Geet Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indexies for submatrix of A\n"
		"	int aBegin= widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B;\n"
		"	__local double As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local double Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	double Dsub = 0;\n"
		"\n"
		"	//Counter for modulus every 32 iterations\n"
		"	int mCount = 0;\n"
		"\n"
		"	//Loop over all the sub-maticies of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matricies from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Dsub += As[ty][0] * Bs[0][tx];\n"
		"		Dsub += As[ty][1] * Bs[1][tx];\n"
		"		Dsub += As[ty][2] * Bs[2][tx];\n"
		"		Dsub += As[ty][3] * Bs[3][tx];\n"
		"		Dsub += As[ty][4] * Bs[4][tx];\n"
		"		Dsub += As[ty][5] * Bs[5][tx];\n"
		"		Dsub += As[ty][6] * Bs[6][tx];\n"
		"		Dsub += As[ty][7] * Bs[7][tx];\n"
		"		Dsub += As[ty][8] * Bs[8][tx];\n"
		"		Dsub += As[ty][9] * Bs[9][tx];\n"
		"		Dsub += As[ty][10] * Bs[10][tx];\n"
		"		Dsub += As[ty][11] * Bs[11][tx];\n"
		"		Dsub += As[ty][12] * Bs[12][tx];\n"
		"		Dsub += As[ty][13] * Bs[13][tx];\n"
		"		Dsub += As[ty][14] * Bs[14][tx];\n"
		"		Dsub += As[ty][15] * Bs[15][tx];\n"
		"\n"
		"		mCount++;\n"
		"\n"
		"		//fmod every 32 iterations\n"
		"		if(mCount == 2){\n"
		"			Dsub = fmod(Dsub, mod);\n"
		"			mCount = 0;\n"
		"		}\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calls fmod once to normalize the sum\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"\n"
		"	//Calculates the offset inthe result matrix\n"
		"	int d = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"\n"
		"	//Load, add, and normalize with element from C\n"
		"	double c = C[d + ty * widthB + tx];\n"
		"	Dsub = Dsub + c;\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"\n"
		"	//Add the sum to the appropriate spot\n"
		"	D[d + ty * widthB + tx] = Dsub;\n"
		"}\n"
	};

	const char* matrixAxpyKernelModular32SP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"\n"
		"__kernel void matrixAxpyKernelModular32SP(__global float* D, __global float* A, __global float* B,\n"
		"		__global float* C, const int widthA, const int widthB, const float mod){\n"
		"	//Geet Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indexies for submatrix of A\n"
		"	int aBegin= widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B;\n"
		"	__local float As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local float Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	float Dsub = 0;\n"
		"\n"
		"	//Counter for modulus every 32 iterations\n"
		"	int mCount = 0;\n"
		"\n"
		"	//Loop over all the sub-maticies of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matricies from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Dsub += As[ty][0] * Bs[0][tx];\n"
		"		Dsub += As[ty][1] * Bs[1][tx];\n"
		"		Dsub += As[ty][2] * Bs[2][tx];\n"
		"		Dsub += As[ty][3] * Bs[3][tx];\n"
		"		Dsub += As[ty][4] * Bs[4][tx];\n"
		"		Dsub += As[ty][5] * Bs[5][tx];\n"
		"		Dsub += As[ty][6] * Bs[6][tx];\n"
		"		Dsub += As[ty][7] * Bs[7][tx];\n"
		"		Dsub += As[ty][8] * Bs[8][tx];\n"
		"		Dsub += As[ty][9] * Bs[9][tx];\n"
		"		Dsub += As[ty][10] * Bs[10][tx];\n"
		"		Dsub += As[ty][11] * Bs[11][tx];\n"
		"		Dsub += As[ty][12] * Bs[12][tx];\n"
		"		Dsub += As[ty][13] * Bs[13][tx];\n"
		"		Dsub += As[ty][14] * Bs[14][tx];\n"
		"		Dsub += As[ty][15] * Bs[15][tx];\n"
		"\n"
		"		mCount++;\n"
		"\n"
		"		//fmod every 32 iterations\n"
		"		if(mCount == 2){\n"
		"			Dsub = fmod(Dsub, mod);\n"
		"			mCount = 0;\n"
		"		}\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calls fmod once to normalize the sum\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"\n"
		"	//Calculates the offset inthe result matrix\n"
		"	int d = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"\n"
		"	//Load, add, and normalize with element from C\n"
		"	float c = C[d + ty * widthB + tx];\n"
		"	Dsub = Dsub + c;\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"\n"
		"	//Add the sum to the appropriate spot\n"
		"	D[d + ty * widthB + tx] = Dsub;\n"
		"}\n"
	};

	const char* matrixAxpyKernelModular1024DP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
		"\n"
		"__kernel void matrixAxpyKernelModular1024DP(__global double* D, __global double* A, __global double* B,\n"
		"		__global double* C, const int widthA, const int widthB, const double mod){\n"
		"	//Geet Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indexies for submatrix of A\n"
		"	int aBegin= widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B;\n"
		"	__local double As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local double Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	double Dsub = 0;\n"
		"\n"
		"	//Counter for modulus every 32 iterations\n"
		"	int mCount = 0;\n"
		"\n"
		"	//Loop over all the sub-maticies of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matricies from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Dsub += As[ty][0] * Bs[0][tx];\n"
		"		Dsub += As[ty][1] * Bs[1][tx];\n"
		"		Dsub += As[ty][2] * Bs[2][tx];\n"
		"		Dsub += As[ty][3] * Bs[3][tx];\n"
		"		Dsub += As[ty][4] * Bs[4][tx];\n"
		"		Dsub += As[ty][5] * Bs[5][tx];\n"
		"		Dsub += As[ty][6] * Bs[6][tx];\n"
		"		Dsub += As[ty][7] * Bs[7][tx];\n"
		"		Dsub += As[ty][8] * Bs[8][tx];\n"
		"		Dsub += As[ty][9] * Bs[9][tx];\n"
		"		Dsub += As[ty][10] * Bs[10][tx];\n"
		"		Dsub += As[ty][11] * Bs[11][tx];\n"
		"		Dsub += As[ty][12] * Bs[12][tx];\n"
		"		Dsub += As[ty][13] * Bs[13][tx];\n"
		"		Dsub += As[ty][14] * Bs[14][tx];\n"
		"		Dsub += As[ty][15] * Bs[15][tx];\n"
		"\n"
		"		mCount++;\n"
		"\n"
		"		//fmod every 1024 iterations\n"
		"		if(mCount == 64){\n"
		"			Dsub = fmod(Dsub, mod);\n"
		"			mCount = 0;\n"
		"		}\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calls fmod once to normalize the sum\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"\n"
		"	//Calculates the offset in the result matrix\n"
		"	int d = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"\n"
		"	//Load, add, and normalize with element from C\n"
		"	double c = C[d + ty * widthB + tx];\n"
		"	Dsub = Dsub + c;\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"\n"
		"	//Add the sum to the appropriate spot\n"
		"	D[d + ty * widthB + tx] = Dsub;\n"
		"}\n"
	};

	const char* matrixAxpyKernelModular1024SP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"\n"
		"__kernel void matrixAxpyKernelModular1024SP(__global float* D, __global float* A, __global float* B,\n"
		"		__global float* C, const int widthA, const int widthB, const float mod){\n"
		"	//Geet Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indexies for submatrix of A\n"
		"	int aBegin= widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B;\n"
		"	__local float As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local float Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	float Dsub = 0;\n"
		"\n"
		"	//Counter for modulus every 32 iterations\n"
		"	int mCount = 0;\n"
		"\n"
		"	//Loop over all the sub-maticies of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matricies from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Dsub += As[ty][0] * Bs[0][tx];\n"
		"		Dsub += As[ty][1] * Bs[1][tx];\n"
		"		Dsub += As[ty][2] * Bs[2][tx];\n"
		"		Dsub += As[ty][3] * Bs[3][tx];\n"
		"		Dsub += As[ty][4] * Bs[4][tx];\n"
		"		Dsub += As[ty][5] * Bs[5][tx];\n"
		"		Dsub += As[ty][6] * Bs[6][tx];\n"
		"		Dsub += As[ty][7] * Bs[7][tx];\n"
		"		Dsub += As[ty][8] * Bs[8][tx];\n"
		"		Dsub += As[ty][9] * Bs[9][tx];\n"
		"		Dsub += As[ty][10] * Bs[10][tx];\n"
		"		Dsub += As[ty][11] * Bs[11][tx];\n"
		"		Dsub += As[ty][12] * Bs[12][tx];\n"
		"		Dsub += As[ty][13] * Bs[13][tx];\n"
		"		Dsub += As[ty][14] * Bs[14][tx];\n"
		"		Dsub += As[ty][15] * Bs[15][tx];\n"
		"\n"
		"		mCount++;\n"
		"\n"
		"		//fmod every 1024 iterations\n"
		"		if(mCount == 64){\n"
		"			Dsub = fmod(Dsub, mod);\n"
		"			mCount = 0;\n"
		"		}\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calls fmod once to normalize the sum\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"\n"
		"	//Calculates the offset inthe result matrix\n"
		"	int d = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"\n"
		"	//Load, add, and normalize with element from C\n"
		"	float c = C[d + ty * widthB + tx];\n"
		"	Dsub = Dsub + c;\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"\n"
		"	//Add the sum to the appropriate spot\n"
		"	D[d + ty * widthB + tx] = Dsub;\n"
		"}\n"
	};

	const char* matrixMaxpyKernelModular1DP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
		"\n"
		"__kernel void matrixMaxpyKernelModular1DP(__global double* D, __global double* A, __global double* B,\n"
		"		__global double* C, const int widthA, const int widthB, const double mod){\n"
		"	//Geet Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indexies for submatrix of A\n"
		"	int aBegin= widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B;\n"
		"	__local double As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local double Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	double Dsub = 0;\n"
		"\n"
		"	//Loop over all the sub-maticies of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matricies from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Dsub += As[ty][0] * Bs[0][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][1] * Bs[1][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][2] * Bs[2][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][3] * Bs[3][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][4] * Bs[4][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][5] * Bs[5][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][6] * Bs[6][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][7] * Bs[7][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][8] * Bs[8][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][9] * Bs[9][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][10] * Bs[10][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][11] * Bs[11][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][12] * Bs[12][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][13] * Bs[13][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][14] * Bs[14][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][15] * Bs[15][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calculates the offset inthe result matrix\n"
		"	int d = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"\n"
		"	//Load, add, and normalize with element from C\n"
		"	double c = C[d + ty * widthB + tx];\n"
		"	Dsub = c - Dsub;\n"
		"	Dsub = fmod((mod + Dsub), mod);\n"
		"\n"
		"	//Add the sum to the appropriate spot\n"
		"	D[d + ty * widthB + tx] = Dsub;\n"
		"}\n"
	};

	const char* matrixMaxpyKernelModular1SP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"\n"
		"__kernel void matrixMaxpyKernelModular1SP(__global float* D, __global float* A, __global float* B,\n"
		"		__global float* C, const int widthA, const int widthB, const float mod){\n"
		"	//Geet Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indexies for submatrix of A\n"
		"	int aBegin= widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B;\n"
		"	__local float As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local float Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	float Dsub = 0;\n"
		"\n"
		"	//Loop over all the sub-maticies of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matricies from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Dsub += As[ty][0] * Bs[0][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][1] * Bs[1][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][2] * Bs[2][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][3] * Bs[3][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][4] * Bs[4][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][5] * Bs[5][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][6] * Bs[6][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][7] * Bs[7][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][8] * Bs[8][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][9] * Bs[9][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][10] * Bs[10][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][11] * Bs[11][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][12] * Bs[12][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][13] * Bs[13][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][14] * Bs[14][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][15] * Bs[15][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calculates the offset inthe result matrix\n"
		"	int d = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"\n"
		"	//Load, add, and normalize with element from C\n"
		"	float c = C[d + ty * widthB + tx];\n"
		"	Dsub = c - Dsub;\n"
		"	Dsub = fmod((mod + Dsub), mod);\n"
		"\n"
		"	//Add the sum to the appropriate spot\n"
		"	D[d + ty * widthB + tx] = Dsub;\n"
		"}\n"
	};

	const char* matrixMaxpyKernelModular8DP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
		"\n"
		"__kernel void matrixMaxpyKernelModular8DP(__global double* D, __global double* A, __global double* B,\n"
		"		__global double* C, const int widthA, const int widthB, const double mod){\n"
		"	//Geet Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indexies for submatrix of A\n"
		"	int aBegin= widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B;\n"
		"	__local double As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local double Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	double Dsub = 0;\n"
		"\n"
		"	//Loop over all the sub-maticies of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matricies from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Dsub += As[ty][0] * Bs[0][tx];\n"
		"		Dsub += As[ty][1] * Bs[1][tx];\n"
		"		Dsub += As[ty][2] * Bs[2][tx];\n"
		"		Dsub += As[ty][3] * Bs[3][tx];\n"
		"		Dsub += As[ty][4] * Bs[4][tx];\n"
		"		Dsub += As[ty][5] * Bs[5][tx];\n"
		"		Dsub += As[ty][6] * Bs[6][tx];\n"
		"		Dsub += As[ty][7] * Bs[7][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"\n"
		"		Dsub += As[ty][8] * Bs[8][tx];\n"
		"		Dsub += As[ty][9] * Bs[9][tx];\n"
		"		Dsub += As[ty][10] * Bs[10][tx];\n"
		"		Dsub += As[ty][11] * Bs[11][tx];\n"
		"		Dsub += As[ty][12] * Bs[12][tx];\n"
		"		Dsub += As[ty][13] * Bs[13][tx];\n"
		"		Dsub += As[ty][14] * Bs[14][tx];\n"
		"		Dsub += As[ty][15] * Bs[15][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calculates the offset inthe result matrix\n"
		"	int d = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"\n"
		"	//Load, add, and normalize with element from C\n"
		"	double c = C[d + ty * widthB + tx];\n"
		"	Dsub = c - Dsub;\n"
		"	Dsub = fmod((mod + Dsub), mod);\n"
		"\n"
		"	//Add the sum to the appropriate spot\n"
		"	D[d + ty * widthB + tx] = Dsub;\n"
		"}\n"
	};

	const char* matrixMaxpyKernelModular16SP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"\n"
		"__kernel void matrixMaxpyKernelModular16SP(__global float* D, __global float* A, __global float* B,\n"
		"		__global float* C, const int widthA, const int widthB, const float mod){\n"
		"	//Geet Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indexies for submatrix of A\n"
		"	int aBegin= widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B;\n"
		"	__local float As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local float Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	float Dsub = 0;\n"
		"\n"
		"	//Loop over all the sub-maticies of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matricies from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Dsub += As[ty][0] * Bs[0][tx];\n"
		"		Dsub += As[ty][1] * Bs[1][tx];\n"
		"		Dsub += As[ty][2] * Bs[2][tx];\n"
		"		Dsub += As[ty][3] * Bs[3][tx];\n"
		"		Dsub += As[ty][4] * Bs[4][tx];\n"
		"		Dsub += As[ty][5] * Bs[5][tx];\n"
		"		Dsub += As[ty][6] * Bs[6][tx];\n"
		"		Dsub += As[ty][7] * Bs[7][tx];\n"
		"		Dsub += As[ty][8] * Bs[8][tx];\n"
		"		Dsub += As[ty][9] * Bs[9][tx];\n"
		"		Dsub += As[ty][10] * Bs[10][tx];\n"
		"		Dsub += As[ty][11] * Bs[11][tx];\n"
		"		Dsub += As[ty][12] * Bs[12][tx];\n"
		"		Dsub += As[ty][13] * Bs[13][tx];\n"
		"		Dsub += As[ty][14] * Bs[14][tx];\n"
		"		Dsub += As[ty][15] * Bs[15][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calculates the offset inthe result matrix\n"
		"	int d = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"\n"
		"	//Load, add, and normalize with element from C\n"
		"	float c = C[d + ty * widthB + tx];\n"
		"	Dsub = c - Dsub;\n"
		"	Dsub = fmod((mod + Dsub), mod);\n"
		"\n"
		"	//Add the sum to the appropriate spot\n"
		"	D[d + ty * widthB + tx] = Dsub;\n"
		"}\n"
	};

	const char* matrixMaxpyKernelModular32DP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
		"\n"
		"__kernel void matrixMaxpyKernelModular32DP(__global double* D, __global double* A, __global double* B,\n"
		"		__global double* C, const int widthA, const int widthB, const double mod){\n"
		"	//Geet Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indexies for submatrix of A\n"
		"	int aBegin= widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B;\n"
		"	__local double As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local double Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	double Dsub = 0;\n"
		"\n"
		"	//Counter for modulus every 32 iterations\n"
		"	int mCount = 0;\n"
		"\n"
		"	//Loop over all the sub-maticies of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matricies from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Dsub += As[ty][0] * Bs[0][tx];\n"
		"		Dsub += As[ty][1] * Bs[1][tx];\n"
		"		Dsub += As[ty][2] * Bs[2][tx];\n"
		"		Dsub += As[ty][3] * Bs[3][tx];\n"
		"		Dsub += As[ty][4] * Bs[4][tx];\n"
		"		Dsub += As[ty][5] * Bs[5][tx];\n"
		"		Dsub += As[ty][6] * Bs[6][tx];\n"
		"		Dsub += As[ty][7] * Bs[7][tx];\n"
		"		Dsub += As[ty][8] * Bs[8][tx];\n"
		"		Dsub += As[ty][9] * Bs[9][tx];\n"
		"		Dsub += As[ty][10] * Bs[10][tx];\n"
		"		Dsub += As[ty][11] * Bs[11][tx];\n"
		"		Dsub += As[ty][12] * Bs[12][tx];\n"
		"		Dsub += As[ty][13] * Bs[13][tx];\n"
		"		Dsub += As[ty][14] * Bs[14][tx];\n"
		"		Dsub += As[ty][15] * Bs[15][tx];\n"
		"\n"
		"		mCount++;\n"
		"\n"
		"		//fmod every 32 iterations\n"
		"		if(mCount == 2){\n"
		"			Dsub = fmod(Dsub, mod);\n"
		"			mCount = 0;\n"
		"		}\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calls fmod once to normalize the sum\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"\n"
		"	//Calculates the offset inthe result matrix\n"
		"	int d = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"\n"
		"	//Load, add, and normalize with element from C\n"
		"	double c = C[d + ty * widthB + tx];\n"
		"	Dsub = c - Dsub;\n"
		"	Dsub = fmod((mod + Dsub), mod);\n"
		"\n"
		"	//Add the sum to the appropriate spot\n"
		"	D[d + ty * widthB + tx] = Dsub;\n"
		"}\n"
	};

	const char* matrixMaxpyKernelModular32SP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"\n"
		"__kernel void matrixMaxpyKernelModular32SP(__global float* D, __global float* A, __global float* B,\n"
		"		__global float* C, const int widthA, const int widthB, const float mod){\n"
		"	//Geet Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indexies for submatrix of A\n"
		"	int aBegin= widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B;\n"
		"	__local float As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local float Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	float Dsub = 0;\n"
		"\n"
		"	//Counter for modulus every 32 iterations\n"
		"	int mCount = 0;\n"
		"\n"
		"	//Loop over all the sub-maticies of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matricies from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Dsub += As[ty][0] * Bs[0][tx];\n"
		"		Dsub += As[ty][1] * Bs[1][tx];\n"
		"		Dsub += As[ty][2] * Bs[2][tx];\n"
		"		Dsub += As[ty][3] * Bs[3][tx];\n"
		"		Dsub += As[ty][4] * Bs[4][tx];\n"
		"		Dsub += As[ty][5] * Bs[5][tx];\n"
		"		Dsub += As[ty][6] * Bs[6][tx];\n"
		"		Dsub += As[ty][7] * Bs[7][tx];\n"
		"		Dsub += As[ty][8] * Bs[8][tx];\n"
		"		Dsub += As[ty][9] * Bs[9][tx];\n"
		"		Dsub += As[ty][10] * Bs[10][tx];\n"
		"		Dsub += As[ty][11] * Bs[11][tx];\n"
		"		Dsub += As[ty][12] * Bs[12][tx];\n"
		"		Dsub += As[ty][13] * Bs[13][tx];\n"
		"		Dsub += As[ty][14] * Bs[14][tx];\n"
		"		Dsub += As[ty][15] * Bs[15][tx];\n"
		"\n"
		"		mCount++;\n"
		"\n"
		"		//fmod every 32 iterations\n"
		"		if(mCount == 2){\n"
		"			Dsub = fmod(Dsub, mod);\n"
		"			mCount = 0;\n"
		"		}\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calls fmod once to normalize the sum\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"\n"
		"	//Calculates the offset inthe result matrix\n"
		"	int d = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"\n"
		"	//Load, add, and normalize with element from C\n"
		"	float c = C[d + ty * widthB + tx];\n"
		"	Dsub = c - Dsub;\n"
		"	Dsub = fmod((mod + Dsub), mod);\n"
		"\n"
		"	//Add the sum to the appropriate spot\n"
		"	D[d + ty * widthB + tx] = Dsub;\n"
		"}\n"
	};

	const char* matrixMaxpyKernelModular1024DP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
		"\n"
		"__kernel void matrixMaxpyKernelModular1024DP(__global double* D, __global double* A, __global double* B,\n"
		"		__global double* C, const int widthA, const int widthB, const double mod){\n"
		"	//Geet Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indexies for submatrix of A\n"
		"	int aBegin= widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B;\n"
		"	__local double As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local double Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	double Dsub = 0;\n"
		"\n"
		"	//Counter for modulus every 32 iterations\n"
		"	int mCount = 0;\n"
		"\n"
		"	//Loop over all the sub-maticies of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matricies from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Dsub += As[ty][0] * Bs[0][tx];\n"
		"		Dsub += As[ty][1] * Bs[1][tx];\n"
		"		Dsub += As[ty][2] * Bs[2][tx];\n"
		"		Dsub += As[ty][3] * Bs[3][tx];\n"
		"		Dsub += As[ty][4] * Bs[4][tx];\n"
		"		Dsub += As[ty][5] * Bs[5][tx];\n"
		"		Dsub += As[ty][6] * Bs[6][tx];\n"
		"		Dsub += As[ty][7] * Bs[7][tx];\n"
		"		Dsub += As[ty][8] * Bs[8][tx];\n"
		"		Dsub += As[ty][9] * Bs[9][tx];\n"
		"		Dsub += As[ty][10] * Bs[10][tx];\n"
		"		Dsub += As[ty][11] * Bs[11][tx];\n"
		"		Dsub += As[ty][12] * Bs[12][tx];\n"
		"		Dsub += As[ty][13] * Bs[13][tx];\n"
		"		Dsub += As[ty][14] * Bs[14][tx];\n"
		"		Dsub += As[ty][15] * Bs[15][tx];\n"
		"\n"
		"		mCount++;\n"
		"\n"
		"		//fmod every 1024 iterations\n"
		"		if(mCount == 64){\n"
		"			Dsub = fmod(Dsub, mod);\n"
		"			mCount = 0;\n"
		"		}\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calls fmod once to normalize the sum\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"\n"
		"	//Calculates the offset in the result matrix\n"
		"	int d = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"\n"
		"	//Load, add, and normalize with element from C\n"
		"	double c = C[d + ty * widthB + tx];\n"
		"	Dsub = c - Dsub;\n"
		"	Dsub = fmod((mod + Dsub), mod);\n"
		"\n"
		"	//Add the sum to the appropriate spot\n"
		"	D[d + ty * widthB + tx] = Dsub;\n"
		"}\n"
	};

	const char* matrixMaxpyKernelModular1024SP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"\n"
		"__kernel void matrixMaxpyKernelModular1024SP(__global float* D, __global float* A, __global float* B,\n"
		"		__global float* C, const int widthA, const int widthB, const float mod){\n"
		"	//Geet Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indexies for submatrix of A\n"
		"	int aBegin= widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B;\n"
		"	__local float As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local float Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	float Dsub = 0;\n"
		"\n"
		"	//Counter for modulus every 32 iterations\n"
		"	int mCount = 0;\n"
		"\n"
		"	//Loop over all the sub-maticies of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matricies from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Dsub += As[ty][0] * Bs[0][tx];\n"
		"		Dsub += As[ty][1] * Bs[1][tx];\n"
		"		Dsub += As[ty][2] * Bs[2][tx];\n"
		"		Dsub += As[ty][3] * Bs[3][tx];\n"
		"		Dsub += As[ty][4] * Bs[4][tx];\n"
		"		Dsub += As[ty][5] * Bs[5][tx];\n"
		"		Dsub += As[ty][6] * Bs[6][tx];\n"
		"		Dsub += As[ty][7] * Bs[7][tx];\n"
		"		Dsub += As[ty][8] * Bs[8][tx];\n"
		"		Dsub += As[ty][9] * Bs[9][tx];\n"
		"		Dsub += As[ty][10] * Bs[10][tx];\n"
		"		Dsub += As[ty][11] * Bs[11][tx];\n"
		"		Dsub += As[ty][12] * Bs[12][tx];\n"
		"		Dsub += As[ty][13] * Bs[13][tx];\n"
		"		Dsub += As[ty][14] * Bs[14][tx];\n"
		"		Dsub += As[ty][15] * Bs[15][tx];\n"
		"\n"
		"		mCount++;\n"
		"\n"
		"		//fmod every 1024 iterations\n"
		"		if(mCount == 64){\n"
		"			Dsub = fmod(Dsub, mod);\n"
		"			mCount = 0;\n"
		"		}\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calls fmod once to normalize the sum\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"\n"
		"	//Calculates the offset inthe result matrix\n"
		"	int d = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"\n"
		"	//Load, add, and normalize with element from C\n"
		"	float c = C[d + ty * widthB + tx];\n"
		"	Dsub = c - Dsub;\n"
		"	Dsub = fmod((mod + Dsub), mod);\n"
		"\n"
		"	//Add the sum to the appropriate spot\n"
		"	D[d + ty * widthB + tx] = Dsub;\n"
		"}\n"
	};

	const char* matrixAxmyKernelModular1DP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
		"\n"
		"__kernel void matrixAxmyKernelModular1DP(__global double* D, __global double* A, __global double* B,\n"
		"		__global double* C, const int widthA, const int widthB, const double mod){\n"
		"	//Geet Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indexies for submatrix of A\n"
		"	int aBegin= widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B;\n"
		"	__local double As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local double Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	double Dsub = 0;\n"
		"\n"
		"	//Loop over all the sub-maticies of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matricies from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Dsub += As[ty][0] * Bs[0][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][1] * Bs[1][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][2] * Bs[2][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][3] * Bs[3][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][4] * Bs[4][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][5] * Bs[5][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][6] * Bs[6][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][7] * Bs[7][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][8] * Bs[8][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][9] * Bs[9][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][10] * Bs[10][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][11] * Bs[11][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][12] * Bs[12][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][13] * Bs[13][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][14] * Bs[14][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][15] * Bs[15][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calculates the offset inthe result matrix\n"
		"	int d = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"\n"
		"	//Load, add, and normalize with element from C\n"
		"	double c = C[d + ty * widthB + tx];\n"
		"	Dsub = Dsub - c;\n"
		"	Dsub = fmod((mod + Dsub), mod);\n"
		"\n"
		"	//Add the sum to the appropriate spot\n"
		"	D[d + ty * widthB + tx] = Dsub;\n"
		"}\n"
	};

	const char* matrixAxmyKernelModular1SP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"\n"
		"__kernel void matrixAxmyKernelModular1SP(__global float* D, __global float* A, __global float* B,\n"
		"		__global float* C, const int widthA, const int widthB, const float mod){\n"
		"	//Geet Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indexies for submatrix of A\n"
		"	int aBegin= widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B;\n"
		"	__local float As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local float Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	float Dsub = 0;\n"
		"\n"
		"	//Loop over all the sub-maticies of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matricies from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Dsub += As[ty][0] * Bs[0][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][1] * Bs[1][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][2] * Bs[2][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][3] * Bs[3][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][4] * Bs[4][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][5] * Bs[5][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][6] * Bs[6][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][7] * Bs[7][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][8] * Bs[8][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][9] * Bs[9][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][10] * Bs[10][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][11] * Bs[11][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][12] * Bs[12][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][13] * Bs[13][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][14] * Bs[14][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"		Dsub += As[ty][15] * Bs[15][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calculates the offset inthe result matrix\n"
		"	int d = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"\n"
		"	//Load, add, and normalize with element from C\n"
		"	float c = C[d + ty * widthB + tx];\n"
		"	Dsub = Dsub - c;\n"
		"	Dsub = fmod((mod + Dsub), mod);\n"
		"\n"
		"	//Add the sum to the appropriate spot\n"
		"	D[d + ty * widthB + tx] = Dsub;\n"
		"}\n"
	};

	const char* matrixAxmyKernelModular8DP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
		"\n"
		"__kernel void matrixAxmyKernelModular8DP(__global double* D, __global double* A, __global double* B,\n"
		"		__global double* C, const int widthA, const int widthB, const double mod){\n"
		"	//Geet Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indexies for submatrix of A\n"
		"	int aBegin= widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B;\n"
		"	__local double As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local double Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	double Dsub = 0;\n"
		"\n"
		"	//Loop over all the sub-maticies of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matricies from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Dsub += As[ty][0] * Bs[0][tx];\n"
		"		Dsub += As[ty][1] * Bs[1][tx];\n"
		"		Dsub += As[ty][2] * Bs[2][tx];\n"
		"		Dsub += As[ty][3] * Bs[3][tx];\n"
		"		Dsub += As[ty][4] * Bs[4][tx];\n"
		"		Dsub += As[ty][5] * Bs[5][tx];\n"
		"		Dsub += As[ty][6] * Bs[6][tx];\n"
		"		Dsub += As[ty][7] * Bs[7][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"\n"
		"		Dsub += As[ty][8] * Bs[8][tx];\n"
		"		Dsub += As[ty][9] * Bs[9][tx];\n"
		"		Dsub += As[ty][10] * Bs[10][tx];\n"
		"		Dsub += As[ty][11] * Bs[11][tx];\n"
		"		Dsub += As[ty][12] * Bs[12][tx];\n"
		"		Dsub += As[ty][13] * Bs[13][tx];\n"
		"		Dsub += As[ty][14] * Bs[14][tx];\n"
		"		Dsub += As[ty][15] * Bs[15][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calculates the offset inthe result matrix\n"
		"	int d = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"\n"
		"	//Load, add, and normalize with element from C\n"
		"	double c = C[d + ty * widthB + tx];\n"
		"	Dsub = Dsub - c;\n"
		"	Dsub = fmod((mod + Dsub), mod);\n"
		"\n"
		"	//Add the sum to the appropriate spot\n"
		"	D[d + ty * widthB + tx] = Dsub;\n"
		"}\n"
	};

	const char* matrixAxmyKernelModular16SP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"\n"
		"__kernel void matrixAxmyKernelModular16SP(__global float* D, __global float* A, __global float* B,\n"
		"		__global float* C, const int widthA, const int widthB, const float mod){\n"
		"	//Geet Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indexies for submatrix of A\n"
		"	int aBegin= widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B;\n"
		"	__local float As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local float Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	float Dsub = 0;\n"
		"\n"
		"	//Loop over all the sub-maticies of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matricies from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Dsub += As[ty][0] * Bs[0][tx];\n"
		"		Dsub += As[ty][1] * Bs[1][tx];\n"
		"		Dsub += As[ty][2] * Bs[2][tx];\n"
		"		Dsub += As[ty][3] * Bs[3][tx];\n"
		"		Dsub += As[ty][4] * Bs[4][tx];\n"
		"		Dsub += As[ty][5] * Bs[5][tx];\n"
		"		Dsub += As[ty][6] * Bs[6][tx];\n"
		"		Dsub += As[ty][7] * Bs[7][tx];\n"
		"		Dsub += As[ty][8] * Bs[8][tx];\n"
		"		Dsub += As[ty][9] * Bs[9][tx];\n"
		"		Dsub += As[ty][10] * Bs[10][tx];\n"
		"		Dsub += As[ty][11] * Bs[11][tx];\n"
		"		Dsub += As[ty][12] * Bs[12][tx];\n"
		"		Dsub += As[ty][13] * Bs[13][tx];\n"
		"		Dsub += As[ty][14] * Bs[14][tx];\n"
		"		Dsub += As[ty][15] * Bs[15][tx];\n"
		"		Dsub = fmod(Dsub, mod);\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calculates the offset inthe result matrix\n"
		"	int d = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"\n"
		"	//Load, add, and normalize with element from C\n"
		"	float c = C[d + ty * widthB + tx];\n"
		"	Dsub = Dsub - c;\n"
		"	Dsub = fmod((mod + Dsub), mod);\n"
		"\n"
		"	//Add the sum to the appropriate spot\n"
		"	D[d + ty * widthB + tx] = Dsub;\n"
		"}\n"
	};

	const char* matrixAxmyKernelModular32DP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
		"\n"
		"__kernel void matrixAxmyKernelModular32DP(__global double* D, __global double* A, __global double* B,\n"
		"		__global double* C, const int widthA, const int widthB, const double mod){\n"
		"	//Geet Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indexies for submatrix of A\n"
		"	int aBegin= widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B;\n"
		"	__local double As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local double Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	double Dsub = 0;\n"
		"\n"
		"	//Counter for modulus every 32 iterations\n"
		"	int mCount = 0;\n"
		"\n"
		"	//Loop over all the sub-maticies of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matricies from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Dsub += As[ty][0] * Bs[0][tx];\n"
		"		Dsub += As[ty][1] * Bs[1][tx];\n"
		"		Dsub += As[ty][2] * Bs[2][tx];\n"
		"		Dsub += As[ty][3] * Bs[3][tx];\n"
		"		Dsub += As[ty][4] * Bs[4][tx];\n"
		"		Dsub += As[ty][5] * Bs[5][tx];\n"
		"		Dsub += As[ty][6] * Bs[6][tx];\n"
		"		Dsub += As[ty][7] * Bs[7][tx];\n"
		"		Dsub += As[ty][8] * Bs[8][tx];\n"
		"		Dsub += As[ty][9] * Bs[9][tx];\n"
		"		Dsub += As[ty][10] * Bs[10][tx];\n"
		"		Dsub += As[ty][11] * Bs[11][tx];\n"
		"		Dsub += As[ty][12] * Bs[12][tx];\n"
		"		Dsub += As[ty][13] * Bs[13][tx];\n"
		"		Dsub += As[ty][14] * Bs[14][tx];\n"
		"		Dsub += As[ty][15] * Bs[15][tx];\n"
		"\n"
		"		mCount++;\n"
		"\n"
		"		//fmod every 32 iterations\n"
		"		if(mCount == 2){\n"
		"			Dsub = fmod(Dsub, mod);\n"
		"			mCount = 0;\n"
		"		}\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calls fmod once to normalize the sum\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"\n"
		"	//Calculates the offset inthe result matrix\n"
		"	int d = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"\n"
		"	//Load, add, and normalize with element from C\n"
		"	double c = C[d + ty * widthB + tx];\n"
		"	Dsub = Dsub - c;\n"
		"	Dsub = fmod((mod + Dsub), mod);\n"
		"\n"
		"	//Add the sum to the appropriate spot\n"
		"	D[d + ty * widthB + tx] = Dsub;\n"
		"}\n"
	};

	const char* matrixAxmyKernelModular32SP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"\n"
		"__kernel void matrixAxmyKernelModular32SP(__global float* D, __global float* A, __global float* B,\n"
		"		__global float* C, const int widthA, const int widthB, const float mod){\n"
		"	//Geet Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indexies for submatrix of A\n"
		"	int aBegin= widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B;\n"
		"	__local float As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local float Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	float Dsub = 0;\n"
		"\n"
		"	//Counter for modulus every 32 iterations\n"
		"	int mCount = 0;\n"
		"\n"
		"	//Loop over all the sub-maticies of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matricies from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Dsub += As[ty][0] * Bs[0][tx];\n"
		"		Dsub += As[ty][1] * Bs[1][tx];\n"
		"		Dsub += As[ty][2] * Bs[2][tx];\n"
		"		Dsub += As[ty][3] * Bs[3][tx];\n"
		"		Dsub += As[ty][4] * Bs[4][tx];\n"
		"		Dsub += As[ty][5] * Bs[5][tx];\n"
		"		Dsub += As[ty][6] * Bs[6][tx];\n"
		"		Dsub += As[ty][7] * Bs[7][tx];\n"
		"		Dsub += As[ty][8] * Bs[8][tx];\n"
		"		Dsub += As[ty][9] * Bs[9][tx];\n"
		"		Dsub += As[ty][10] * Bs[10][tx];\n"
		"		Dsub += As[ty][11] * Bs[11][tx];\n"
		"		Dsub += As[ty][12] * Bs[12][tx];\n"
		"		Dsub += As[ty][13] * Bs[13][tx];\n"
		"		Dsub += As[ty][14] * Bs[14][tx];\n"
		"		Dsub += As[ty][15] * Bs[15][tx];\n"
		"\n"
		"		mCount++;\n"
		"\n"
		"		//fmod every 32 iterations\n"
		"		if(mCount == 2){\n"
		"			Dsub = fmod(Dsub, mod);\n"
		"			mCount = 0;\n"
		"		}\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calls fmod once to normalize the sum\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"\n"
		"	//Calculates the offset inthe result matrix\n"
		"	int d = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"\n"
		"	//Load, add, and normalize with element from C\n"
		"	float c = C[d + ty * widthB + tx];\n"
		"	Dsub = Dsub - c;\n"
		"	Dsub = fmod((mod + Dsub), mod);\n"
		"\n"
		"	//Add the sum to the appropriate spot\n"
		"	D[d + ty * widthB + tx] = Dsub;\n"
		"}\n"
	};

	const char* matrixAxmyKernelModular1024DP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
		"\n"
		"__kernel void matrixAxmyKernelModular1024DP(__global double* D, __global double* A, __global double* B,\n"
		"		__global double* C, const int widthA, const int widthB, const double mod){\n"
		"	//Geet Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indexies for submatrix of A\n"
		"	int aBegin= widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B;\n"
		"	__local double As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local double Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	double Dsub = 0;\n"
		"\n"
		"	//Counter for modulus every 32 iterations\n"
		"	int mCount = 0;\n"
		"\n"
		"	//Loop over all the sub-maticies of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matricies from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Dsub += As[ty][0] * Bs[0][tx];\n"
		"		Dsub += As[ty][1] * Bs[1][tx];\n"
		"		Dsub += As[ty][2] * Bs[2][tx];\n"
		"		Dsub += As[ty][3] * Bs[3][tx];\n"
		"		Dsub += As[ty][4] * Bs[4][tx];\n"
		"		Dsub += As[ty][5] * Bs[5][tx];\n"
		"		Dsub += As[ty][6] * Bs[6][tx];\n"
		"		Dsub += As[ty][7] * Bs[7][tx];\n"
		"		Dsub += As[ty][8] * Bs[8][tx];\n"
		"		Dsub += As[ty][9] * Bs[9][tx];\n"
		"		Dsub += As[ty][10] * Bs[10][tx];\n"
		"		Dsub += As[ty][11] * Bs[11][tx];\n"
		"		Dsub += As[ty][12] * Bs[12][tx];\n"
		"		Dsub += As[ty][13] * Bs[13][tx];\n"
		"		Dsub += As[ty][14] * Bs[14][tx];\n"
		"		Dsub += As[ty][15] * Bs[15][tx];\n"
		"\n"
		"		mCount++;\n"
		"\n"
		"		//fmod every 1024 iterations\n"
		"		if(mCount == 64){\n"
		"			Dsub = fmod(Dsub, mod);\n"
		"			mCount = 0;\n"
		"		}\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calls fmod once to normalize the sum\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"\n"
		"	//Calculates the offset in the result matrix\n"
		"	int d = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"\n"
		"	//Load, add, and normalize with element from C\n"
		"	double c = C[d + ty * widthB + tx];\n"
		"	Dsub = Dsub - c;\n"
		"	Dsub = fmod((mod + Dsub), mod);\n"
		"\n"
		"	//Add the sum to the appropriate spot\n"
		"	D[d + ty * widthB + tx] = Dsub;\n"
		"}\n"
	};

	const char* matrixAxmyKernelModular1024SP = {
		"\n"
		"#define BLOCK_SIZE 16\n"
		"\n"
		"__kernel void matrixAxmyKernelModular1024SP(__global float* D, __global float* A, __global float* B,\n"
		"		__global float* C, const int widthA, const int widthB, const float mod){\n"
		"	//Geet Workgroup ID\n"
		"	int bx = get_group_id(0);\n"
		"	int by = get_group_id(1);\n"
		"\n"
		"	//Get Local ID\n"
		"	int tx = get_local_id(0);\n"
		"	int ty = get_local_id(1);\n"
		"\n"
		"	//Range of indexies for submatrix of A\n"
		"	int aBegin= widthA * BLOCK_SIZE * by;\n"
		"	int aEnd = aBegin + widthA - 1;\n"
		"	int aStep = BLOCK_SIZE;\n"
		"\n"
		"	//Range of indecies for sub-matrix of B\n"
		"	int bBegin = BLOCK_SIZE * bx;\n"
		"	int bStep = BLOCK_SIZE * widthB;\n"
		"\n"
		"	//Local storage of sub-matrices of A and B;\n"
		"	__local float As[BLOCK_SIZE][BLOCK_SIZE];\n"
		"	__local float Bs[BLOCK_SIZE][BLOCK_SIZE];\n"
		"\n"
		"	//Temporary storage for result\n"
		"	float Dsub = 0;\n"
		"\n"
		"	//Counter for modulus every 32 iterations\n"
		"	int mCount = 0;\n"
		"\n"
		"	//Loop over all the sub-maticies of A and B required to compute\n"
		"	//the result sub-matrix\n"
		"	for(int a = aBegin, b = bBegin; a < aEnd; a += aStep, b += bStep){\n"
		"		//Load the matricies from global memory to local memory\n"
		"		//Each thread loads one element of each sub-matrix\n"
		"		As[ty][tx] = A[a + widthA * ty + tx];\n"
		"		Bs[ty][tx] = B[b + widthB * ty + tx];\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"\n"
		"		//Multiply the two sub-matrices together\n"
		"		Dsub += As[ty][0] * Bs[0][tx];\n"
		"		Dsub += As[ty][1] * Bs[1][tx];\n"
		"		Dsub += As[ty][2] * Bs[2][tx];\n"
		"		Dsub += As[ty][3] * Bs[3][tx];\n"
		"		Dsub += As[ty][4] * Bs[4][tx];\n"
		"		Dsub += As[ty][5] * Bs[5][tx];\n"
		"		Dsub += As[ty][6] * Bs[6][tx];\n"
		"		Dsub += As[ty][7] * Bs[7][tx];\n"
		"		Dsub += As[ty][8] * Bs[8][tx];\n"
		"		Dsub += As[ty][9] * Bs[9][tx];\n"
		"		Dsub += As[ty][10] * Bs[10][tx];\n"
		"		Dsub += As[ty][11] * Bs[11][tx];\n"
		"		Dsub += As[ty][12] * Bs[12][tx];\n"
		"		Dsub += As[ty][13] * Bs[13][tx];\n"
		"		Dsub += As[ty][14] * Bs[14][tx];\n"
		"		Dsub += As[ty][15] * Bs[15][tx];\n"
		"\n"
		"		mCount++;\n"
		"\n"
		"		//fmod every 1024 iterations\n"
		"		if(mCount == 64){\n"
		"			Dsub = fmod(Dsub, mod);\n"
		"			mCount = 0;\n"
		"		}\n"
		"\n"
		"		//Synchronize threads\n"
		"		barrier(CLK_LOCAL_MEM_FENCE);\n"
		"	}\n"
		"	//Calls fmod once to normalize the sum\n"
		"	Dsub = fmod(Dsub, mod);\n"
		"\n"
		"	//Calculates the offset inthe result matrix\n"
		"	int d = widthB * BLOCK_SIZE * by + BLOCK_SIZE * bx;\n"
		"\n"
		"	//Load, add, and normalize with element from C\n"
		"	float c = C[d + ty * widthB + tx];\n"
		"	Dsub = Dsub - c;\n"
		"	Dsub = fmod((mod + Dsub), mod);\n"
		"\n"
		"	//Add the sum to the appropriate spot\n"
		"	D[d + ty * widthB + tx] = Dsub;\n"
		"}\n"
	};

} /* end of namespace LinBox */

#endif /* __LINBOX_opencl_matrix_domain_kernels_INL */